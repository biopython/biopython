# Copyright 2011 by Andrew Sczesnak.  All rights reserved.
# Revisions Copyright 2011 by Peter Cock.  All rights reserved.
#
# This code is part of the Biopython distribution and governed by its
# license.  Please see the LICENSE file that should have been included
# as part of this package.
"""Bio.AlignIO support for the "maf" multiple alignment format.

You are expected to use this module via the Bio.AlignIO functions(or the
Bio.SeqIO functions if you want to work directly with the gapped sequences).

"""
from Bio.Alphabet import single_letter_alphabet
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Align.Generic import Alignment
from Bio.Align import MultipleSeqAlignment
from Interfaces import SequentialAlignmentWriter

class MafWriter(SequentialAlignmentWriter):
    """Accepts a MultipleSeqAlignment object, writes a MAF file.
    
    More later.
    """
    
    def write_header(self):
        self.handle.write ("##maf version=1 scoring=none\n")
        self.handle.write ("# generated by Biopython\n\n")

    def _write_record (self, record):
        fields = ["s",
                  #In the MAF file format, spaces are not allowed in the id
                  "%-40s" % record.id.replace(" ","_"),
                  "%15s" % record.annotations.get("start", 0),
                  "%5s" % record.annotations.get("size", len(str(record.seq).replace("-",""))),
                  record.annotations.get("strand", "+"),
                  "%15s" % record.annotations.get("srcSize", 0),
                  str(record.seq)]
        self.handle.write(" ".join(fields) + "\n")

    def write_alignment(self, alignment):
        if not isinstance(alignment, Alignment):
            raise TypeError("Expected an alignment object")
        
        if len(set([len(x) for x in alignment])) > 1:
            raise ValueError("Sequences must all be the same length")

        all_ids = [x.id for x in alignment]

        if len(all_ids) != len(set(all_ids)):
            raise ValueError("Identifiers in each MultipleSeqAlignment must be unique")

        # for now, use ._annotations private property, but restrict keys to those
        # specifically supported by the MAF format, according to spec
        try:
            anno = " ".join(["%s=%s" % (x, y) for x, y in alignment._annotations.iteritems() if x in ("score", "pass")])
        except AttributeError:
            anno = "score=0.00"

        self.handle.write("a %s\n" % (anno,))

        recs_out = 0

        for record in alignment:
            self._write_record(record)

            recs_out += 1

        self.handle.write("\n")

        return recs_out
        
def MafIterator(handle, seq_count = None, alphabet = single_letter_alphabet, expect_header = True):
    track_data = False
    header_data = False
        
    if expect_header == True:
        def _parse_track_line(line):
            import shlex
            
            _valid_track_keys = ("name", "mafDot", "visibility", "frames", "speciesOrder", "description")
    
            parsed_track_line = dict(x.split("=") for x in shlex.split(line)[1:])
    
            invalid_keys = [x for x in parsed_track_line.keys() if x not in _valid_track_keys]
                
            if len(invalid_keys) > 0:
                raise ValueError("Error parsing MAF header -- invalid keys: %s" % (" ".join (invalid_keys,)))           
    
            if "speciesOrder" in parsed_track_line:
                parsed_track_line["speciesOrder"] = parsed_track_line["speciesOrder"].split(" ")
                    
                if len(parsed_track_line["speciesOrder"]) <> len(set(parsed_track_line["speciesOrder"])):
                    raise ValueError("Error parsing MAF header -- duplicate entry in speciesOrder")
                    
            return parsed_track_line
            
        def _parse_header_line(line):
            import shlex
            
            _valid_header_keys = ("version", "scoring")
    
            parsed_header_line = dict(x.split("=") for x in shlex.split(line)[1:])
    
            invalid_keys = [x for x in parsed_header_line.keys() if x not in _valid_header_keys]
                
            if len(invalid_keys) > 0:
                raise ValueError("Error parsing MAF header -- invalid keys: %s" % (" ".join (invalid_keys,)))
                
            return parsed_header_line
        
        header_line = handle.next()
        
        if header_line.startswith("track"):
            track_data = _parse_track_line(header_line)
            
            header_line = handle.next()
            
        if header_line.startswith("##"):
            header_data = _parse_header_line(header_line)
        else:
            raise ValueError("Did not find MAF header!")

    in_a_bundle = False
    
    annotations = []
    records = []
    
    while True:
        # allows parsing of the last bundle without duplicating code
        try:
            line = handle.next()
        except StopIteration:
            line = ""
        
        if in_a_bundle:
            if line.startswith("s"):
                # add a SeqRecord to the bundle
                line_split = line.strip().split()

                if len(line_split) <> 7:
                    raise ValueError("Error parsing alignment - 's' line must have 7 fields")

                # s (literal), src (ID), start, size, strand, srcSize, text (sequence)
                anno = {"start": int(line_split[2]),
                        "size": int(line_split[3]),
                        "strand": line_split[4],
                        "srcSize": int(line_split[5])}
                        
                sequence = line_split[6]
                
                # interpret a dot/period to mean same the first sequence
                if "." in sequence:
                    if not records:
                        raise ValueError("Found dot/period in first sequence of alignment")
                        
                    ref = str(records[0].seq)
                    new = []
                    
                    for (s, r) in zip(sequence, ref):
                        new.append(r if s == "." else s)
                             
                    sequence = "".join(new)
                    
                records.append(SeqRecord(Seq(sequence, alphabet),
                               id = line_split[1],
                               name = line_split[1],
                               description = "",
                               annotations = anno))
            elif line.startswith("e") or \
                 line.startswith("i") or \
                 line.startswith("q"):
                # not implemented
                pass
            elif not line.strip():
                # end a bundle of records
                if seq_count is not None:
                    assert len(records) == seq_count
                    
                alignment = MultipleSeqAlignment(records, alphabet)
                #TODO - Introduce an annotated alignment class?
                #See also Bio/AlignIO/FastaIO.py for same requirement.        
                #For now, store the annotation a new private property:
                alignment._annotations = annotations
                
                yield alignment
                
                in_a_bundle = False
                
                annotations = []
                records = []
            else:
                raise ValueError("Error parsing alignment - unexpected line:\n%s" % (line,))
        elif line.startswith("a"):
            # start a bundle of records
            in_a_bundle = True
            
            annotations = dict([x.split("=") for x in line.strip().split()[1:]])
                
            if len([x for x in annotations.iterkeys() if x not in ("score", "pass")]) > 0:
                raise ValueError("Error parsing alignment - invalid key in 'a' line")
        elif line.startswith("#"):
            # ignore comments
            pass
        elif not line:
            break
