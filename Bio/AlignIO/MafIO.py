# Copyright 2011 by Andrew Sczesnak.  All rights reserved.
# Revisions Copyright 2011 by Peter Cock.  All rights reserved.
#
# This code is part of the Biopython distribution and governed by its
# license.  Please see the LICENSE file that should have been included
# as part of this package.
"""Bio.AlignIO support for the "maf" multiple alignment format.

You are expected to use this module via the Bio.AlignIO functions(or the
Bio.SeqIO functions if you want to work directly with the gapped sequences).

"""
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Align.Generic import Alignment
from Bio.Align import MultipleSeqAlignment
from Interfaces import AlignmentIterator, SequentialAlignmentWriter

class MafWriter(SequentialAlignmentWriter):
    """Accepts a MultipleSeqAlignment object, writes a MAF file.
    
    More later.
    """
    
    def write_header(self):
        self.handle.write ("##maf version=1 scoring=none\n")
        self.handle.write ("# generated by Biopython\n\n")

    def _write_record (self, record):
        fields = ["s",
                  #In the MAF file format, spaces are not allowed in the id
                  "%-40s" % record.id.replace(" ","_"),
                  "%15s" % record.annotations.get("start", 0),
                  #TODO - Should default this exclude the gaps?
                  "%5s" % record.annotations.get("size", len(record)),
                  record.annotations.get("strand", "+"),
                  "%15s" % record.annotations.get("srcSize", 0),
                  str(record.seq)]
        self.handle.write(" ".join(fields) + "\n")

    def write_alignment(self, alignment):

        if not isinstance(alignment, Alignment):
            raise TypeError("Expected an alignment object")
        
        if len(set([len(x) for x in alignment])) > 1:
            raise ValueError("Sequences must all be the same length")

        all_ids = [x.id for x in alignment]

        if len(all_ids) != len(set(all_ids)):
            raise ValueError("Identifiers in each MultipleSeqAlignment must be unique")

        # for this format, there really should be an 'annotations' dict at the level
        # of the alignment object, not just SeqRecords
        try:
            anno = " ".join(["%s=%s" % (x, y) for x, y in alignment.annotations.iteritems()])
        except AttributeError:
            anno = "score=0.00"

        self.handle.write("a %s\n" % (anno,))

        recs_out = 0

        for record in alignment:
            self._write_record(record)

            recs_out += 1

        self.handle.write("\n")

        return recs_out

class MafIterator(AlignmentIterator):
    """Returns iterator over specified handle, of MultipleSeqAlignment objects.
    
    More later.
    """
    
    def _fetch_bundle(self):
        bundle = []

        # iterate through file, capture a bundle of lines
        try:
            line = self._lastline
            del self._lastline
        except AttributeError:
            line = self.handle.readline()

        while line:
            if line[0] == "a":
                if len(bundle) > 0:
                    # save this line for next time.  avoids manipulation of
                    # the file pointer for handles like sys.stdin
                    self._lastline = line
                    break

                bundle = [line]
            elif line[0] == "#" or line == "\n":
                pass
            else:
                bundle.append(line)

            line = self.handle.readline()

        return bundle

    @staticmethod
    def _parse_bundle(bundle):
        # "s" line field names for making dicts
        _s_line_fields = ("start", "size", "strand", "srcSize", "text")

        # stores the "a" line and all "s" lines
        bundle_ids = []
        bundle_s_lines = {}
        bundle_a_line = None

        # parse everything
        for line in bundle:
            if line[0] == "s":
                line_split = line.strip().split()

                if len(line_split) <> 7:
                    raise ValueError("Error parsing alignment - 's' line must have 7 fields")

                idn = line_split[1]
                bundle_ids.append(idn)
                bundle_s_lines[idn] = dict(zip(_s_line_fields, line_split[2:]))
            elif line[0] == "a":
                if bundle_a_line != None:
                    raise ValueError("Error parsing alignment - multiple 'a' lines in one bundle")

                bundle_a_line = dict([x.split("=") for x in line.strip().split()[1:]])

            ##TODO
            # parse 'i' 'q' 'e' lines?

        if len(bundle_ids) <> len(set(bundle_ids)):
            raise ValueError("Error parsing alignment - duplicate ID in one bundle")

        return(bundle_a_line, bundle_s_lines, bundle_ids)

    def _build_alignment(self, parsed_bundle):
        # build the multiple alignment object
        alignment = MultipleSeqAlignment([], self.alphabet)

        #TODO - Introduce an annotated alignment class?
        #See also Bio/AlignIO/FastaIO.py for same requirement.        
        #For now, store the annotation a new private property:
        alignment._annotations = parsed_bundle[0]

        for idn in parsed_bundle[2]:
            species_data = parsed_bundle[1][idn]
            anno = {"start": int(species_data["start"]),
                    "srcSize": int(species_data["srcSize"]),
                    "strand": species_data["strand"],
                    "size": int(species_data["size"])}

            sequence = species_data["text"]
            #Interpret a dot/period to mean same the first sequence
            if "." in sequence:
                if idn == parsed_bundle[2][0]:
                    raise ValueError("Found dot/period in first sequence of alignment")
                ref = parsed_bundle[1][parsed_bundle[2][0]]["text"]
                new = []
                for (s, r) in zip(sequence, ref):
                    if s == ".":
                        new.append(r)
                    else:
                        new.append(s)
                sequence = "".join(new)

            record = SeqRecord(Seq(sequence, self.alphabet),
                               id = idn,
                               name = idn,
                               description = "",
                               annotations = anno)

            alignment.append(record)

        return alignment

    def next(self):
        try:
            _ = self._header
        except AttributeError:
            def _check_nextline_header():
                line = self.handle.readline()

                if line[:15] == "##maf version=1":
                    self._header = line.strip()
                    
                    return True
                else:
                    return line
            
            line = _check_nextline_header()
            
            if line == True:
                pass            
            elif not line:
                raise StopIteration
            elif line[:5] == "track":
                import shlex
                
                _valid_track_keys = ("name", "mafDot", "visibility", "frames", "speciesOrder", "description")

                parsed_track_line = dict(x.split("=") for x in shlex.split(line)[1:])

                invalid_keys = [x for x in parsed_track_line.keys() if x not in _valid_track_keys]
                
                if len(invalid_keys) > 0:
                    raise ValueError("Error parsing MAF header -- invalid keys: %s" % (" ".join (invalid_keys,)))           
                    
                self._track = parsed_track_line
                
                if "speciesOrder" in self._track:
                    self._track["speciesOrder"] = self._track["speciesOrder"].split(" ")
                    
                    if len(self._track["speciesOrder"]) <> len(set(self._track["speciesOrder"])):
                        raise ValueError("Error parsing MAF header -- duplicate entry in speciesOrder")
                
                # next line better be the header!
                line = _check_nextline_header()

            if line != True:
                raise ValueError("Did not find MAF header")

        # handoff to bundle fetcher
        bundle = self._fetch_bundle()

        if len(bundle) == 0:
            raise StopIteration

        # handoff to bundle parser
        parsed_bundle = self._parse_bundle(bundle)

        # handoff to alignment builder
        return self._build_alignment(parsed_bundle)