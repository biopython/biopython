# Copyright 2011, 2012 by Andrew Sczesnak.  All rights reserved.
# Revisions Copyright 2011, 2017 by Peter Cock.  All rights reserved.
# Revisions Copyright 2014, 2015 by Adam Novak.  All rights reserved.
# Revisions Copyright 2015, 2017 by Blaise Li.  All rights reserved.
#
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.
"""Bio.Align support for the "maf" multiple alignment format.

The Multiple Alignment Format, described by UCSC, stores a series of
multiple alignments in a single file. It is suitable for whole-genome
to whole-genome alignments, metadata such as source chromosome, start
position, size, and strand can be stored.

See http://genome.ucsc.edu/FAQ/FAQformat.html#format5

You are expected to use this module via the Bio.Align functions.

Coordinates in the MAF format are defined in terms of zero-based start
positions (like Python) and aligning region sizes.

A minimal aligned region of length one and starting at first position in the
source sequence would have ``start == 0`` and ``size == 1``.

As we can see on this example, ``start + size`` will give one more than the
zero-based end position. We can therefore manipulate ``start`` and
``start + size`` as python list slice boundaries.
"""
import os

from itertools import chain


from Bio.Align import Alignment
from Bio.Align import interfaces
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord


class AlignmentWriter(interfaces.AlignmentWriter):
    """Accepts Alignment objects, writes a MAF file."""

    def write_header(self):
        """Write the MAF header."""
        self.stream.write("##maf version=1 scoring=none\n")
        self.stream.write("# generated by Biopython\n\n")

    def _write_record(self, record):
        """Write a single SeqRecord object to an 's' line in a MAF block (PRIVATE)."""
        # convert biopython-style 1/-1 strand to MAF-style +/- strand
        if record.annotations.get("strand") == 1:
            strand = "+"
        elif record.annotations.get("strand") == -1:
            strand = "-"
        else:
            # TODO: issue warning?
            strand = "+"

        fields = [
            "s",
            # In the MAF file format, spaces are not allowed in the id
            "%-40s" % record.id.replace(" ", "_"),
            "%15s" % record.annotations.get("start", 0),
            "%5s"
            % record.annotations.get("size", len(str(record.seq).replace("-", ""))),
            strand,
            "%15s" % record.annotations.get("srcSize", 0),
            str(record.seq),
        ]
        self.stream.write(f"{' '.join(fields)}\n")

    def write_alignment(self, alignment):
        """Write a complete alignment to a MAF block.

        Writes every SeqRecord in a MultipleSeqAlignment object to its own
        MAF block (beginning with an 'a' line, containing 's' lines).
        """
        if not isinstance(alignment, MultipleSeqAlignment):
            raise TypeError("Expected an alignment object")

        if len({len(x) for x in alignment}) > 1:
            raise ValueError("Sequences must all be the same length")

        # We allow multiple sequences with the same IDs; for example, there may
        # be a MAF aligning the + and - strands of the same sequence together.

        # for now, use ._annotations private property, but restrict keys to those
        # specifically supported by the MAF format, according to spec
        try:
            anno = " ".join(
                [
                    f"{x}={y}"
                    for x, y in alignment._annotations.items()
                    if x in ("score", "pass")
                ]
            )
        except AttributeError:
            anno = "score=0.00"

        self.stream.write(f"a {anno}\n")

        recs_out = 0

        for record in alignment:
            self._write_record(record)

            recs_out += 1

        self.stream.write("\n")

        return recs_out


class AlignmentIterator(interfaces.AlignmentIterator):

    status_characters = ("C", "I", "N", "n", "M", "T")

    def __init__(self, source):
        """Create an AlignmentIterator object.

        Arguments:
         - source   - input data or file name

        """
        super().__init__(source, mode="t", fmt="MAF")
        stream = self.stream
        line = next(stream)
        words = line.split()
        assert words[0] == "##maf"
        metadata = {}
        for word in words[1:]:
            key, value = words[1].split("=")
            assert key in ("version", "scoring", "program")
            metadata[key] = value
        if metadata.get("version") != "1":
            raise ValueError("MAF version must be 1")
        try:
            line = next(stream)
        except StopIteration:
            self.stream = None
        else:
            if line.startswith("#"):
                metadata["comment"] = line[1:].strip()
                self.line = None
            else:
                self.line = line
        self.metadata = metadata

    @staticmethod
    def create_alignment(records, aligned_sequences, annotations, score):
        coordinates = Alignment.infer_coordinates(aligned_sequences)
        alignment = Alignment(records, coordinates)
        if annotations is not None:
            alignment.annotations = annotations
        if score is not None:
            alignment.score = score
        return alignment

    def parse(self, stream):
        """Parse the next alignment from the stream."""
        if stream is None:
            raise StopIteration

        line = self.line
        self.line = None
        if line is not None:
            lines = chain([line], stream)
        else:
            lines = stream
        records = None
        for line in lines:
            if line.startswith("a "):
                annotations = {}
                records = []
                aligned_sequences = []
                score = None
                words = line[2:].split()
                for word in words:
                    key, value = word.split("=")
                    if key == "score":
                        score = float(value)
                    elif key == "pass":
                        value = int(value)
                        assert value > 0
                        annotations["pass"] = value
                    else:
                        raise ValueError("Unknown annotation variable '%s'" % key)
            elif line.startswith("s "):
                words = line.strip().split()
                if len(words) != 7:
                    raise ValueError(
                        "Error parsing alignment - 's' line must have 7 fields"
                    )
                src = words[1]
                start = int(words[2])
                size = int(words[3])
                strand = words[4]
                srcSize = int(words[5])
                text = words[6]
                aligned_sequences.append(text)
                sequence = text.replace("-", "")
                assert len(sequence) == size
                seq = Seq({start: sequence}, length=srcSize)
                record = SeqRecord(seq, id=src)
                records.append(record)
            elif line.startswith("i "):
                words = line.strip().split()
                assert len(words) == 6
                assert words[1] == src  # from the previous "s" line
                leftStatus = words[2]
                leftCount = int(words[3])
                rightStatus = words[4]
                rightCount = int(words[5])
                assert leftStatus in AlignmentIterator.status_characters
                assert rightStatus in AlignmentIterator.status_characters
                annotations["leftStatus"] = leftStatus
                annotations["leftCount"] = leftCount
                annotations["rightStatus"] = rightStatus
                annotations["rightCount"] = rightCount
            elif line.startswith("e"):
                # TODO: information about the size of the gap between the alignments
                # that span the current block
                pass
            elif line.startswith("q"):
                # TODO: quality of each aligned base for the species.
                # Need to find documentation on this, looks like ASCII 0-9 or gap?
                # Can then store in each SeqRecord's .letter_annotations dictionary,
                # perhaps as the raw string or turned into integers / None for gap?
                pass
            elif line.startswith("#"):
                # ignore comments
                # (not sure whether comments
                # are in the maf specification, though)
                pass
            elif not line.strip():
                # reached the end of this alignment
                yield AlignmentIterator.create_alignment(records, aligned_sequences, annotations, score)
            else:
                raise ValueError(f"Error parsing alignment - unexpected line:\n{line}")
        if records is None:
            return
        yield AlignmentIterator.create_alignment(records, aligned_sequences, annotations, score)
