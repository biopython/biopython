# Copyright 2011, 2012 by Andrew Sczesnak.  All rights reserved.
# Revisions Copyright 2011, 2017 by Peter Cock.  All rights reserved.
# Revisions Copyright 2014, 2015 by Adam Novak.  All rights reserved.
# Revisions Copyright 2015, 2017 by Blaise Li.  All rights reserved.
#
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.
"""Bio.Align support for the "maf" multiple alignment format.

The Multiple Alignment Format, described by UCSC, stores a series of
multiple alignments in a single file. It is suitable for whole-genome
to whole-genome alignments, metadata such as source chromosome, start
position, size, and strand can be stored.

See http://genome.ucsc.edu/FAQ/FAQformat.html#format5

You are expected to use this module via the Bio.Align functions.

Coordinates in the MAF format are defined in terms of zero-based start
positions (like Python) and aligning region sizes.

A minimal aligned region of length one and starting at first position in the
source sequence would have ``start == 0`` and ``size == 1``.

As we can see on this example, ``start + size`` will give one more than the
zero-based end position. We can therefore manipulate ``start`` and
``start + size`` as python list slice boundaries.
"""
import os
import shlex

from itertools import chain


from Bio.Align import Alignment
from Bio.Align import interfaces
from Bio.Seq import Seq, reverse_complement
from Bio.SeqRecord import SeqRecord


class AlignmentWriter(interfaces.AlignmentWriter):
    """Accepts Alignment objects, writes a MAF file."""

    def write_header(self):
        """Write the MAF header."""
        self.stream.write("##maf version=1 scoring=none\n")
        self.stream.write("# generated by Biopython\n\n")

    def _write_record(self, record):
        """Write a single SeqRecord object to an 's' line in a MAF block (PRIVATE)."""
        # convert biopython-style 1/-1 strand to MAF-style +/- strand
        if record.annotations.get("strand") == 1:
            strand = "+"
        elif record.annotations.get("strand") == -1:
            strand = "-"
        else:
            # TODO: issue warning?
            strand = "+"

        fields = [
            "s",
            # In the MAF file format, spaces are not allowed in the id
            "%-40s" % record.id.replace(" ", "_"),
            "%15s" % record.annotations.get("start", 0),
            "%5s"
            % record.annotations.get("size", len(str(record.seq).replace("-", ""))),
            strand,
            "%15s" % record.annotations.get("srcSize", 0),
            str(record.seq),
        ]
        self.stream.write(f"{' '.join(fields)}\n")

    def write_alignment(self, alignment):
        """Write a complete alignment to a MAF block.

        Writes every SeqRecord in a MultipleSeqAlignment object to its own
        MAF block (beginning with an 'a' line, containing 's' lines).
        """
        if not isinstance(alignment, MultipleSeqAlignment):
            raise TypeError("Expected an alignment object")

        if len({len(x) for x in alignment}) > 1:
            raise ValueError("Sequences must all be the same length")

        # We allow multiple sequences with the same IDs; for example, there may
        # be a MAF aligning the + and - strands of the same sequence together.

        # for now, use ._annotations private property, but restrict keys to those
        # specifically supported by the MAF format, according to spec
        try:
            anno = " ".join(
                [
                    f"{x}={y}"
                    for x, y in alignment._annotations.items()
                    if x in ("score", "pass")
                ]
            )
        except AttributeError:
            anno = "score=0.00"

        self.stream.write(f"a {anno}\n")

        recs_out = 0

        for record in alignment:
            self._write_record(record)

            recs_out += 1

        self.stream.write("\n")

        return recs_out


class AlignmentIterator(interfaces.AlignmentIterator):

    status_characters = ("C", "I", "N", "n", "M", "T")
    empty_status_characters = ("C", "I", "M", "n")

    def __init__(self, source):
        """Create an AlignmentIterator object.

        Arguments:
         - source   - input data or file name

        """
        super().__init__(source, mode="t", fmt="MAF")
        stream = self.stream
        metadata = {}
        line = next(stream)
        if line.startswith("track "):
            words = shlex.split(line)
            for word in words[1:]:
                key, value = word.split("=")
                if key in ("name", "description", "frames"):
                    pass
                elif key == "mafDot":
                    if value not in ("on", "off"):
                        raise ValueError("Variable mafDot in track line has Unexpected value '%s'" % value)
                elif key == "visibility":
                    if value not in ("dense", "pack", "full"):
                        raise ValueError("Variable visibility in track line has Unexpected value '%s'" % value)
                elif key == "speciesOrder":
                    value = value.split()
                else:
                    raise ValueError("Unexpected variable '%s' in track line" % key)
                metadata[key] = value
            line = next(stream)
        words = line.split()
        if words[0] != "##maf":
            raise ValueError("header line does not start with ##maf")
        for word in words[1:]:
            key, value = word.split("=")
            if key not in ("version", "scoring", "program"):
                raise ValueError("Unexpected variable '%s' in header line" % key)
            metadata[key] = value
        if metadata.get("version") != "1":
            raise ValueError("MAF version must be 1")
        comments = []
        for line in stream:
            if line.strip():
                if not line.startswith("#"):
                    self.line = line
                    break
                comment = line[1:].strip()
                comments.append(comment)
        else:
            self.stream = None
            self.line = None
        if comments:
            metadata["comments"] = comments
        self.metadata = metadata

    @staticmethod
    def create_alignment(records, aligned_sequences, starts, strands, annotations, column_annotations, score):
        coordinates = Alignment.infer_coordinates(aligned_sequences)
        for start, strand, row in zip(starts, strands, coordinates):
            if strand == "-":
                row[:] = row[-1] - row[0] - row
            row += start
        alignment = Alignment(records, coordinates)
        if annotations is not None:
            alignment.annotations = annotations
        if column_annotations is not None:
            alignment.column_annotations = column_annotations
        if score is not None:
            alignment.score = score
        return alignment

    def parse(self, stream):
        """Parse the next alignment from the stream."""
        if stream is None:
            raise StopIteration

        line = self.line
        self.line = None
        if line is not None:
            lines = chain([line], stream)
        else:
            lines = stream
        records = None
        for line in lines:
            if line.startswith("a"):
                starts = []
                strands = []
                annotations = {}
                column_annotations = {}
                records = []
                aligned_sequences = []
                score = None
                words = line[1:].split()
                for word in words:
                    key, value = word.split("=")
                    if key == "score":
                        score = float(value)
                    elif key == "pass":
                        value = int(value)
                        if value <= 0:
                            raise ValueError("pass value must be positive (found %d)" % value)
                        annotations["pass"] = value
                    else:
                        raise ValueError("Unknown annotation variable '%s'" % key)
            elif line.startswith("s "):
                words = line.strip().split()
                if len(words) != 7:
                    raise ValueError(
                        "Error parsing alignment - 's' line must have 7 fields"
                    )
                src = words[1]
                start = int(words[2])
                size = int(words[3])
                strand = words[4]
                srcSize = int(words[5])
                text = words[6]
                for gap_char in ".=_":
                    text = text.replace(gap_char, "-")
                aligned_sequences.append(text)
                sequence = text.replace("-", "")
                if len(sequence) != size:
                    raise ValueError("sequence size is incorrect (found %d, expected %d)" % (len(sequence), size))
                if strand == "-":
                    sequence = reverse_complement(sequence)
                    start = srcSize - start - size
                seq = Seq({start: sequence}, length=srcSize)
                record = SeqRecord(seq, id=src)
                records.append(record)
                starts.append(start)
                strands.append(strand)
            elif line.startswith("i "):
                words = line.strip().split()
                assert len(words) == 6
                assert words[1] == src  # from the previous "s" line
                leftStatus = words[2]
                leftCount = int(words[3])
                rightStatus = words[4]
                rightCount = int(words[5])
                assert leftStatus in AlignmentIterator.status_characters
                assert rightStatus in AlignmentIterator.status_characters
                record.annotations["leftStatus"] = leftStatus
                record.annotations["leftCount"] = leftCount
                record.annotations["rightStatus"] = rightStatus
                record.annotations["rightCount"] = rightCount
            elif line.startswith("e"):
                words = line[1:].split()
                assert len(words) == 6
                src = words[0]
                start = int(words[1])
                size = int(words[2])
                strand = words[3]
                srcSize = int(words[4])
                status = words[5]
                assert status in AlignmentIterator.empty_status_characters
                sequence = Seq(None, length=srcSize)
                record = SeqRecord(sequence, id=src)
                end = start + size
                if strand == "+":
                    segment = (start, end)
                else:
                    segment = (srcSize - start, srcSize - end)
                empty = (record, segment, status)
                annotation = annotations.get("empty")
                if annotation is None:
                    annotation = []
                    annotations["empty"] = annotation
                annotation.append(empty)
            elif line.startswith("q "):
                words = line.strip().split()
                assert len(words) == 3
                assert words[1] == src  # from the previous "s" line
                value = words[2]
                column_annotations[src] = value
            elif not line.strip():
                # reached the end of this alignment
                yield AlignmentIterator.create_alignment(records, aligned_sequences, starts, strands, annotations, column_annotations, score)
                records = None
            else:
                raise ValueError(f"Error parsing alignment - unexpected line:\n{line}")
        if records is None:
            return
        yield AlignmentIterator.create_alignment(records, aligned_sequences, starts, strands, annotations, column_annotations, score)
