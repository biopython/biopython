\chapter{Sequence alignments}
\label{chapter:align}

Sequence alignments are a collection of two or more sequences that have been aligned to each other -- usually with the insertion of gaps, and the addition of leading or trailing gaps -- such that all the sequence strings are the same length.

Alignments may extend over the full length of each sequence, or may be limited to a subsection of each sequence. In Biopython, all sequence alignments are represented by an \verb|Alignment| object, described in section~\ref{sec:alignmentobject}. \verb|Alignment| objects can be obtained by parsing the output of alignment software such as Clustal or BLAT (described in section+\ref{sec:alignmentparsers}. or by using Biopython's pairwise sequence aligner, which can align two sequences to each other (described in chapter~\ref{chapter:pairwise}).

See Chapter~\ref{chapter:msa} for a description of the older \verb|MultipleSeqAlignment| class and the parsers in \verb|Bio.AlignIO| that parse the output of sequence alignment software, generating \verb|MultipleSeqAlignment| objects.

\section{Alignment objects}
\label{sec:alignmentobject}

The \verb|Alignment| class is defined in \verb|Bio.Align|. Usually you would get an \verb|Alignment| object by parsing the output of alignment programs (section~\ref{sec:alignmentparsers}) or by running Biopython's pairwise aligner (chapter~\ref{chapter:pairwise}). For the benefit of this section, however, we will create an \verb|Alignment| object from scratch.

Suppose you have three sequences:
%doctest . lib:numpy
\begin{minted}{pycon}
>>> seqA = "CGTTTTT"
>>> seqB = "CGATTTTT"
>>> seqC = "GTGGTTT"
>>> sequences = [seqA, seqB, seqC]
\end{minted}
These sequences can be plain strings, \verb|bytes| objects, \verb|Seq| objects,  or \verb|SeqRecord| objects. To create an \verb|Alignment| object, we also need the coordinates that define how the sequences are aligned to each other. We use a numpy array for that:
%cont-doctest
\begin{minted}{pycon}
>>> import numpy as np
>>> coordinates = np.array([[0, 2, 2, 5, 7], [0, 2, 3, 6, 8], [1, 3, 4, 7, 7]])
\end{minted}
These coordinates indicate that the following sequence segments are aligned to each other:
\begin{itemize}
\item \verb|SeqA[0:2]|, \verb|SeqB[0:2]|, and \verb|SeqC[1:3]|;
\item \verb|SeqB[2:3]| and \verb|SeqC[3:4]|, with a gap of one nucleotide in \verb|seqA|;
\item \verb|SeqA[2:5]|, \verb|SeqB[3:6]|, and \verb|SeqC[4:7]|;
\item \verb|SeqA[5:7]| and \verb|SeqB[6:8]|, with a gap of two nucleotides in \verb|seqC|.
\end{itemize}
Note that the alignment does not include the first nucleotide and last two nucleotides of \verb|seqC|.

Now we can create the \verb|Alignment| object:
%cont-doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignment = Align.Alignment(sequences, coordinates)
>>> alignment  # doctest: +ELLIPSIS
<Alignment object (3 rows x 8 columns) at ...>
\end{minted}
The alignment object has an attribute \verb|sequences| pointing to the sequences that were aligned:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.sequences
['CGTTTTT', 'CGATTTTT', 'GTGGTTT']
\end{minted}
and an attribute \verb|coordinates| with the alignment coordinates:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.coordinates
array([[0, 2, 2, 5, 7],
       [0, 2, 3, 6, 8],
       [1, 3, 4, 7, 7]])
\end{minted}
Print the \verb+Alignment+ object to show the alignment explicitly:
%cont-doctest
\begin{minted}{pycon}
>>> print(alignment)
                  0 CG-TTTTT 7
                  0 CGATTTTT 8
                  1 TGGTTT-- 7
<BLANKLINE>
\end{minted}
with the starting and end coordinate for each sequence are shown to the left and right, respectively, of the alignment.

The number of aligned sequences is returned by \verb+len(alignment)+:
%cont-doctest
\begin{minted}{pycon}
>>> len(alignment)
3
\end{minted}
The alignment length is defined as the number of columns in the alignment as
printed. This is equal to the sum of the number of matches, number of
mismatches, and the total length of gaps in each sequence:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.length
8
\end{minted}

The \verb+shape+ property returns a tuple consisting of the length of the
alignment and the number of columns in the alignment as printed:

%cont-doctest
\begin{minted}{pycon}
>>> alignment.shape
(3, 8)
\end{minted}
Note that sections that are not aligned are not included in the number of columns.

The \verb+sort+ method sorts the alignment sequences. By default, sorting is done based on the \verb+id+ attribute of each sequence if available, or the sequence contents otherwise.
%cont-doctest
\begin{minted}{pycon}
>>> print(alignment)
                  0 CG-TTTTT 7
                  0 CGATTTTT 8
                  1 TGGTTT-- 7
<BLANKLINE>
>>> alignment.sort()
>>> print(alignment)
                  0 CGATTTTT 8
                  0 CG-TTTTT 7
                  1 TGGTTT-- 7
<BLANKLINE>
\end{minted}
Alternatively, you can supply a \verb+key+ function to determine the sort order. For example, you can sort the sequences by increasing GC content:
%cont-doctest
\begin{minted}{pycon}
>>> from Bio.SeqUtils import gc_fraction
>>> alignment.sort(key=gc_fraction)
>>> print(alignment)
                  0 CGATTTTT 8
                  0 CG-TTTTT 7
                  1 TGGTTT-- 7
<BLANKLINE>
\end{minted}
Note that the \verb+key+ function is applied to the full sequence (including the initial G nucleotide of \verb|seqC|), not just to the aligned part.

The \verb+reverse+ argument lets you reverse the sort order to obtain the sequences in decreasing GC content:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.sort(key=gc_fraction, reverse=True)
>>> print(alignment)
                  1 TGGTTT-- 7
                  0 CG-TTTTT 7
                  0 CGATTTTT 8
<BLANKLINE>
\end{minted}

The \verb+frequencies+ method calculates how often each letter appears in each column of the alignment:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.frequencies  # doctest: +NORMALIZE_WHITESPACE
{'T': array([1, 0, 0, 3, 3, 3, 2, 2]),
 'G': array([0, 3, 1, 0, 0, 0, 0, 0]),
 'C': array([2, 0, 0, 0, 0, 0, 0, 0]),
 'A': array([0, 0, 1, 0, 0, 0, 0, 0])}
\end{minted}
Use the \verb+substitutions+ method to find the number of substitutions between each pair of nucleotides:
%cont-doctest
\begin{minted}{pycon}
>>> m = alignment.substitutions
>>> print(m)
    A   C   G    T
A 0.0 0.0 0.0  0.0
C 0.0 1.0 0.0  0.0
G 1.0 0.0 3.0  0.0
T 0.0 2.0 0.0 11.0
<BLANKLINE>
\end{minted}

Note that the matrix is not symmetric: The counts for a row letter R and a column letter C is the number of times letter R in a sequence is replaced by letter C in a sequence appearing below it. For example, the number of T's that are aligned to a C in a later sequence is
%cont-doctest
\begin{minted}{pycon}
>>> m["T", "C"]
2.0
\end{minted}
while the number of C's that are aligned to a T in a later sequence is
%cont-doctest
\begin{minted}{pycon}
>>> m["C", "T"]
0.0
\end{minted}
To get a symmetric matrix, use
%cont-doctest
\begin{minted}{pycon}
>>> m += m.transpose()
>>> m /= 2.0
>>> print(m)
    A   C   G    T
A 0.0 0.0 0.5  0.0
C 0.0 1.0 0.0  1.0
G 0.5 0.0 3.0  0.0
T 0.0 1.0 0.0 11.0
<BLANKLINE>
>>> m["T", "C"]
1.0
>>> m["C", "T"]
1.0
\end{minted}
The total number of substitutions between C's and T's in the alignment is 1.0 + 1.0 = 2.

\section{Slicing and indexing an alignment}

Slices of the form \verb+alignment[k, i:j]+, where \verb+k+ is an integer and \verb+i+ and \verb+j+ are integers or are absent, return a string showing the aligned sequence (including gaps) for the target (if \verb+k=0+) or the query (if \verb+k=1+) that includes only the columns \verb+i+ through \verb+j+ in the printed alignment.

To illustrate this, in the following example the printed alignment has 8 columns:

%cont-doctest
\begin{minted}{pycon}
>>> print(alignment)
                  1 TGGTTT-- 7
                  0 CG-TTTTT 7
                  0 CGATTTTT 8
<BLANKLINE>
>>> alignment.length
8
\end{minted}

To get the aligned sequence strings individually, use
%cont-doctest
\begin{minted}{pycon}
>>> alignment[0]
'TGGTTT--'
>>> alignment[1]
'CG-TTTTT'
>>> alignment[2]
'CGATTTTT'
>>> alignment[0, :]
'TGGTTT--'
>>> alignment[1, :]
'CG-TTTTT'
>>> alignment[0, 1:-1]
'GGTTT-'
>>> alignment[1, 1:-1]
'G-TTTT'
\end{minted}

Columns to be included can also be selected using an iterable over integers:
%cont-doctest
\begin{minted}{pycon}
>>> alignment[0, (1, 3, 4)]
'GTT'
>>> alignment[1, range(0, 5, 2)]
'C-T'
\end{minted}

To get specific columns in the alignment, use
%cont-doctest
\begin{minted}{pycon}
>>> alignment[:, 0]
'TCC'
>>> alignment[:, 1]
'GGG'
>>> alignment[:, 2]
'G-A'
\end{minted}

Slices of the form \verb+alignment[:, i:j]+, where \verb+i+ and \verb+j+ are integers or are absent, return a new \verb+Alignment+ object that includes only the columns \verb+i+ through \verb+j+ in the printed alignment.

Extracting the first 4 columns for the example alignment above gives:
%cont-doctest
\begin{minted}{pycon}
>>> alignment[:, :4]  # doctest:+ELLIPSIS
<Alignment object (3 rows x 4 columns) at ...>
>>> print(alignment[:, :4])
                  1 TGGT 5
                  0 CG-T 3
                  0 CGAT 4
<BLANKLINE>
\end{minted}

Similarly, extracting the last 3 columns gives:
%cont-doctest
\begin{minted}{pycon}
>>> alignment[:, -3:]  # doctest:+ELLIPSIS
<Alignment object (3 rows x 3 columns) at ...>
>>> print(alignment[:, -3:])
                  6 T-- 7
                  4 TTT 7
                  5 TTT 8
<BLANKLINE>
\end{minted}

The column index can also be an iterable of integers:
%cont-doctest
\begin{minted}{pycon}
>>> print(alignment[:, (1, 3, 0)])
                  0 GTT 3
                  0 GTC 3
                  0 GTC 3
<BLANKLINE>
\end{minted}

\section{Reverse-complementing the alignment}

Reverse-complementing an alignment will take the reverse complement of each sequence, and recalculate the coordinates:
%cont-doctest
\begin{minted}{pycon}
>>> print(alignment.sequences)
['GTGGTTT', 'CGTTTTT', 'CGATTTTT']
>>> rc_alignment = alignment.reverse_complement()
>>> print(rc_alignment.sequences)
['AAACCAC', 'AAAAACG', 'AAAAATCG']
>>> print(rc_alignment)
                  0 --AAACCA 6
                  0 AAAAA-CG 7
                  0 AAAAATCG 8
<BLANKLINE>
>>> print(alignment[:, :4].sequences)
['GTGGTTT', 'CGTTTTT', 'CGATTTTT']
>>> print(alignment[:, :4])
                  1 TGGT 5
                  0 CG-T 3
                  0 CGAT 4
<BLANKLINE>
>>> rc_alignment = alignment[:, :4].reverse_complement()
>>> print(rc_alignment[:, :4].sequences)
['AAACCAC', 'AAAAACG', 'AAAAATCG']
>>> print(rc_alignment[:, :4])
                  2 ACCA 6
                  4 A-CG 7
                  4 ATCG 8
<BLANKLINE>
\end{minted}
Reverse-complementing an alignment preserves its column annotations (in reverse order), but discards all other annotations.

\section{Reading and writing alignments}
\label{sec:alignmentparsers}

Output from sequence alignment software such as Clustal can be parsed into \verb|Alignment| objects by the \verb|Bio.Align.read| and \verb|Bio.Align.parse| functions. Their usage is analogous to the \verb|read| and \verb|parse| functions in \verb|Bio.SeqIO| (see Section~\ref{sec:Bio.SeqIO-input}): The \verb|read| function is used to read an output file containing a single alignment and returns an \verb|Alignment| object, while the \verb|parse| function returns an iterator to iterate over alignments stored in an output file containing one or more alignments. The table below shows the alignment formats that can be parsed in \verb|Bio.Align|. \verb|Bio.Align| provides a \verb|write| function that can write alignments in most of these formats, as shown in the table.

\begin{table}[!htbp]
\begin{center}
\begin{tabular}{|l|l|c|c|c|}
File format \verb+fmt+ & Description & text / binary & Supported by \verb|write| & Subsection \\
\verb|a2m| & A2M & text & yes & \ref{subsec:align_a2m} \\
\verb|bed| & Browser Extensible Data (BED) & text & yes & \ref{subsec:align_bed} \\
\verb|bigbed| & bigBed & binary & yes & \ref{subsec:align_bigbed} \\
\verb|bigmaf| & bigMaf & binary & yes & \ref{subsec:align_bigmaf} \\
\verb|bigpsl| & bigPsl & binary & yes & \ref{subsec:align_bigpsl} \\
\verb|clustal| & ClustalW & text & yes & \ref{subsec:align_clustal} \\
\verb|emboss| & EMBOSS & text & no & \ref{subsec:align_emboss} \\
\verb|exonerate| & Exonerate & text & yes & \ref{subsec:align_exonerate} \\
\verb|fasta| & Aligned FASTA & text & yes & \ref{subsec:align_fasta} \\
\verb|hhr| & HH-suite output files & text & no & \ref{subsec:align_hhr} \\
\verb|maf| & Multiple Alignment Format (MAF) & text & yes & \ref{subsec:align_maf} \\
\verb|mauve| & Mauve eXtended Multi-FastA (xmfa) format & text & yes & \ref{subsec:align_mauve} \\
\verb|msf| & GSG Multiple Sequence Format (MSF) & text & no & \ref{subsec:align_msf} \\
\verb|nexus| & Nexus & text & yes & \ref{subsec:align_nexus} \\
\verb|phylip| & PHYLIP output files & text & yes & \ref{subsec:align_phylip} \\
\verb|psl| & Pattern Space Layout (PSL) & text & yes & \ref{subsec:align_psl} \\
\verb|sam| & Sequence Alignment/Map (SAM) & text & yes & \ref{subseq:align_sam} \\
\verb|stockholm| & Stockholm & text & yes & \ref{subsec:align_stockholm} \\
\verb|tabular| & Tabular output from BLAST or FASTA & text & no & \ref{subsec:align_tabular} \\
\end{tabular}
\end{center}
\end{table}

These formats are described in detail in Section~\ref{sec:alignformats}. The format argument \verb|fmt| is case-insensitive.

\subsection{Reading alignments}

The alignments returned by \verb|Bio.Align.parse| inherit from the \verb|AlignmentsAbstractBaseClass| base class. This class defines a \verb|rewind| method that resets the iterator to let it loop over the alignments from the beginning. You can also call \verb|len| on the alignments to obtain the number of alignments. Depending on the file format, the number of alignments may be explicitly stored in the file (for example in the case of bigBed, bigPsl, and bigMaf files), or otherwise the number of alignments is counted by looping over them once (and returning the iterator to its original position). If the file is large, it may therefore take a considerable amount of time for \verb|len| to return. As the number of alignments is cached, subsequent calls to \verb|len| will return quickly.

Depending on the file format, the alignments object returned by \verb|Bio.Align.parse| may contain attributes that store metadata found in the file, such as the version number of the software that was used to create the alignments. The specific attributes stored for each file format are described in Section~\ref{sec:alignformats}.

\subsection{Writing alignments}
\label{subsec:align_writing}

To write alignments to a file, use
\begin{minted}{pycon}
>>> from Bio import Align
>>> target = "myfile.txt"
>>> Align.write(alignments, target, "clustal")
\end{minted}
where \verb|alignments| is either a single alignment or a list of alignments, \verb|target| is a file name or an open file-like object, and \verb|fmt| is the file format. As some file formats allow or require metadata to be stored with the alignments, you may want to use the \verb|Alignments| (plural) class instead of a plain list of alignments. This class inherits from \verb|AlignmentsAbstractBaseClass| as well as from \verb|list|, and can therefore be used as a list, but also allows you to store metadata as attributes on the \verb|alignments| object:
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.Alignments(alignments)
>>> metadata = {"Program": "Biopython", "Version": "1.81"}
>>> alignments.metadata = metadata
>>> target = "myfile.txt"
>>> Align.write(alignments, target, "clustal")
\end{minted}

\subsection{Printing alignments}
\label{subsec:align_printing}

For text (non-binary) formats, you can call Python's built-in \verb|format| function on an alignment to get a string showing the alignment in the requested format, or use \verb|Alignment| objects in formatted (f-) strings. As optional keyword arguments cannot be used with Python's built-in \verb|format| function or with formatted strings, the \verb|Alignment| class has a \verb|format| method with optional arguments to customize the alignment format, as described in the subsections below. When called with an empty string (which is the default), \verb|format| returns a human-readable representation of the alignment (same as when you \verb|print| the alignment).

\section{Alignment file formats}
\label{sec:alignformats}

\subsection{Aligned FASTA}
\label{subsec:align_fasta}

Files in the aligned FASTA format store exactly one (pairwise or multiple) sequence alignment, in which gaps in the alignment are represented by dashes (\verb|-|). Use \verb|fmt="fasta"| to read or write files in the aligned FASTA format. Note that this is different from output generated by William Pearson's FASTA alignment program (parsing such output is described in section~\ref{subsec:align_tabular} instead).

The file \verb+probcons.fa+ in Biopython's test suite stores one multiple alignment in the aligned FASTA format. The contents of this file is as follows:
\begin{minted}{text}
>plas_horvu
D-VLLGANGGVLVFEPNDFSVKAGETITFKNNAGYPHNVVFDEDAVPSG-VD-VSKISQEEYLTAPGETFSVTLTV---PGTYGFYCEPHAGAGMVGKVTV
>plas_chlre
--VKLGADSGALEFVPKTLTIKSGETVNFVNNAGFPHNIVFDEDAIPSG-VN-ADAISRDDYLNAPGETYSVKLTA---AGEYGYYCEPHQGAGMVGKIIV
>plas_anava
--VKLGSDKGLLVFEPAKLTIKPGDTVEFLNNKVPPHNVVFDAALNPAKSADLAKSLSHKQLLMSPGQSTSTTFPADAPAGEYTFYCEPHRGAGMVGKITV
>plas_proho
VQIKMGTDKYAPLYEPKALSISAGDTVEFVMNKVGPHNVIFDK--VPAG-ES-APALSNTKLRIAPGSFYSVTLGT---PGTYSFYCTPHRGAGMVGTITV
>azup_achcy
VHMLNKGKDGAMVFEPASLKVAPGDTVTFIPTDK-GHNVETIKGMIPDG-AE-A-------FKSKINENYKVTFTA---PGVYGVKCTPHYGMGMVGVVEV
\end{minted}

To read this file, use
%doctest ../Tests/Clustalw lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignment = Align.read("probcons.fa", "fasta")
>>> alignment  # doctest: +ELLIPSIS
<Alignment object (5 rows x 101 columns) at ...>
\end{minted}
We can print the alignment to see its default representation:
%cont-doctest
\begin{minted}{pycon}
>>> print(alignment)
plas_horv         0 D-VLLGANGGVLVFEPNDFSVKAGETITFKNNAGYPHNVVFDEDAVPSG-VD-VSKISQE
plas_chlr         0 --VKLGADSGALEFVPKTLTIKSGETVNFVNNAGFPHNIVFDEDAIPSG-VN-ADAISRD
plas_anav         0 --VKLGSDKGLLVFEPAKLTIKPGDTVEFLNNKVPPHNVVFDAALNPAKSADLAKSLSHK
plas_proh         0 VQIKMGTDKYAPLYEPKALSISAGDTVEFVMNKVGPHNVIFDK--VPAG-ES-APALSNT
azup_achc         0 VHMLNKGKDGAMVFEPASLKVAPGDTVTFIPTDK-GHNVETIKGMIPDG-AE-A------
<BLANKLINE>
plas_horv        57 EYLTAPGETFSVTLTV---PGTYGFYCEPHAGAGMVGKVTV 95
plas_chlr        56 DYLNAPGETYSVKLTA---AGEYGYYCEPHQGAGMVGKIIV 94
plas_anav        58 QLLMSPGQSTSTTFPADAPAGEYTFYCEPHRGAGMVGKITV 99
plas_proh        56 KLRIAPGSFYSVTLGT---PGTYSFYCTPHRGAGMVGTITV 94
azup_achc        51 -FKSKINENYKVTFTA---PGVYGVKCTPHYGMGMVGVVEV 88
<BLANKLINE>
\end{minted}
or we can print it in the aligned FASTA format:
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "fasta"))
>plas_horvu
D-VLLGANGGVLVFEPNDFSVKAGETITFKNNAGYPHNVVFDEDAVPSG-VD-VSKISQEEYLTAPGETFSVTLTV---PGTYGFYCEPHAGAGMVGKVTV
>plas_chlre
--VKLGADSGALEFVPKTLTIKSGETVNFVNNAGFPHNIVFDEDAIPSG-VN-ADAISRDDYLNAPGETYSVKLTA---AGEYGYYCEPHQGAGMVGKIIV
>plas_anava
--VKLGSDKGLLVFEPAKLTIKPGDTVEFLNNKVPPHNVVFDAALNPAKSADLAKSLSHKQLLMSPGQSTSTTFPADAPAGEYTFYCEPHRGAGMVGKITV
>plas_proho
VQIKMGTDKYAPLYEPKALSISAGDTVEFVMNKVGPHNVIFDK--VPAG-ES-APALSNTKLRIAPGSFYSVTLGT---PGTYSFYCTPHRGAGMVGTITV
>azup_achcy
VHMLNKGKDGAMVFEPASLKVAPGDTVTFIPTDK-GHNVETIKGMIPDG-AE-A-------FKSKINENYKVTFTA---PGVYGVKCTPHYGMGMVGVVEV
<BLANKLINE>
\end{minted}
or any other available format, for example Clustal (see section~\ref{subsec:align_clustal}):
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "clustal"))
plas_horvu                          D-VLLGANGGVLVFEPNDFSVKAGETITFKNNAGYPHNVVFDEDAVPSG-
plas_chlre                          --VKLGADSGALEFVPKTLTIKSGETVNFVNNAGFPHNIVFDEDAIPSG-
plas_anava                          --VKLGSDKGLLVFEPAKLTIKPGDTVEFLNNKVPPHNVVFDAALNPAKS
plas_proho                          VQIKMGTDKYAPLYEPKALSISAGDTVEFVMNKVGPHNVIFDK--VPAG-
azup_achcy                          VHMLNKGKDGAMVFEPASLKVAPGDTVTFIPTDK-GHNVETIKGMIPDG-
<BLANKLINE>
plas_horvu                          VD-VSKISQEEYLTAPGETFSVTLTV---PGTYGFYCEPHAGAGMVGKVT
plas_chlre                          VN-ADAISRDDYLNAPGETYSVKLTA---AGEYGYYCEPHQGAGMVGKII
plas_anava                          ADLAKSLSHKQLLMSPGQSTSTTFPADAPAGEYTFYCEPHRGAGMVGKIT
plas_proho                          ES-APALSNTKLRIAPGSFYSVTLGT---PGTYSFYCTPHRGAGMVGTIT
azup_achcy                          AE-A-------FKSKINENYKVTFTA---PGVYGVKCTPHYGMGMVGVVE
<BLANKLINE>
plas_horvu                          V
plas_chlre                          V
plas_anava                          V
plas_proho                          V
azup_achcy                          V
<BLANKLINE>
<BLANKLINE>
<BLANKLINE>
\end{minted}
The sequences associated with the alignment are \verb|SeqRecord| objects:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.sequences
[SeqRecord(seq=Seq('DVLLGANGGVLVFEPNDFSVKAGETITFKNNAGYPHNVVFDEDAVPSGVDVSKI...VTV'), id='plas_horvu', name='<unknown name>', description='', dbxrefs=[]), SeqRecord(seq=Seq('VKLGADSGALEFVPKTLTIKSGETVNFVNNAGFPHNIVFDEDAIPSGVNADAIS...IIV'), id='plas_chlre', name='<unknown name>', description='', dbxrefs=[]), SeqRecord(seq=Seq('VKLGSDKGLLVFEPAKLTIKPGDTVEFLNNKVPPHNVVFDAALNPAKSADLAKS...ITV'), id='plas_anava', name='<unknown name>', description='', dbxrefs=[]), SeqRecord(seq=Seq('VQIKMGTDKYAPLYEPKALSISAGDTVEFVMNKVGPHNVIFDKVPAGESAPALS...ITV'), id='plas_proho', name='<unknown name>', description='', dbxrefs=[]), SeqRecord(seq=Seq('VHMLNKGKDGAMVFEPASLKVAPGDTVTFIPTDKGHNVETIKGMIPDGAEAFKS...VEV'), id='azup_achcy', name='<unknown name>', description='', dbxrefs=[])]
\end{minted}
Note that these sequences do not contain gaps ("\verb|-|" characters), as the alignment information is stored in the \verb|coordinates| attribute instead:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.coordinates
array([[ 0,  1,  1, 33, 34, 42, 44, 48, 48, 50, 50, 51, 58, 73, 73, 95],
       [ 0,  0,  0, 32, 33, 41, 43, 47, 47, 49, 49, 50, 57, 72, 72, 94],
       [ 0,  0,  0, 32, 33, 41, 43, 47, 48, 50, 51, 52, 59, 74, 77, 99],
       [ 0,  1,  2, 34, 35, 43, 43, 47, 47, 49, 49, 50, 57, 72, 72, 94],
       [ 0,  1,  2, 34, 34, 42, 44, 48, 48, 50, 50, 51, 51, 66, 66, 88]])
\end{minted}
Use \verb|Align.write| to write this alignment to a file (here, we'll use a \verb|StringIO| object instead of a file):
%cont-doctest
\begin{minted}{pycon}
>>> from io import StringIO
>>> stream = StringIO()
>>> Align.write(alignment, stream, "FASTA")
1
>>> print(stream.getvalue())
>plas_horvu
D-VLLGANGGVLVFEPNDFSVKAGETITFKNNAGYPHNVVFDEDAVPSG-VD-VSKISQEEYLTAPGETFSVTLTV---PGTYGFYCEPHAGAGMVGKVTV
>plas_chlre
--VKLGADSGALEFVPKTLTIKSGETVNFVNNAGFPHNIVFDEDAIPSG-VN-ADAISRDDYLNAPGETYSVKLTA---AGEYGYYCEPHQGAGMVGKIIV
>plas_anava
--VKLGSDKGLLVFEPAKLTIKPGDTVEFLNNKVPPHNVVFDAALNPAKSADLAKSLSHKQLLMSPGQSTSTTFPADAPAGEYTFYCEPHRGAGMVGKITV
>plas_proho
VQIKMGTDKYAPLYEPKALSISAGDTVEFVMNKVGPHNVIFDK--VPAG-ES-APALSNTKLRIAPGSFYSVTLGT---PGTYSFYCTPHRGAGMVGTITV
>azup_achcy
VHMLNKGKDGAMVFEPASLKVAPGDTVTFIPTDK-GHNVETIKGMIPDG-AE-A-------FKSKINENYKVTFTA---PGVYGVKCTPHYGMGMVGVVEV
<BLANKLINE>
\end{minted}
Note that \verb|Align.write| returns the number of alignments written (1, in this case).

\subsection{ClustalW}
\label{subsec:align_clustal}

Clustal is a set of multiple sequence alignment programs that are available both as standalone programs as as web servers. The file \verb|opuntia.aln| (available online or in the Doc/examples subdirectory of the Biopython source code) is an output file generated by Clustal. Its first few lines are
\begin{minted}{text}
CLUSTAL 2.1 multiple sequence alignment


gi|6273285|gb|AF191659.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273284|gb|AF191658.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273287|gb|AF191661.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273286|gb|AF191660.1|AF191      TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273290|gb|AF191664.1|AF191      TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273289|gb|AF191663.1|AF191      TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273291|gb|AF191665.1|AF191      TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
                                    ******* **** *************************************

...
\end{minted}
To parse this file, use
%doctest examples lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.parse("opuntia.aln", "clustal")
\end{minted}
The \verb|metadata| attribute on \verb|alignments| stores the information shown in the file header:
%cont-doctest
\begin{minted}{pycon}
>>> alignments.metadata
{'Program': 'CLUSTAL', 'Version': '2.1'}
\end{minted}
You can call \verb|next| on the \verb|alignments| to pull out the first (and only) alignment:
%cont-doctest
\begin{minted}{pycon}
>>> alignment = next(alignments)
>>> print(alignment)  # doctest: +ELLIPSIS
gi|627328         0 TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
gi|627328         0 TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
gi|627328         0 TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
gi|627328         0 TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
gi|627329         0 TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
gi|627328         0 TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
gi|627329         0 TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
<BLANKLINE>
gi|627328        60 CTAAATGATATACGATTCCACTATGTAAGGTCTTTGAATCATATCATAAAAGACAATGTA
gi|627328        60 CTAAATGATATACGATTCCACTATGTAAGGTCTTTGAATCATATCATAAAAGACAATGTA
gi|627328        60 CTAAATGATATACGATTCCACTATGTAAGGTCTTTGAATCATATCATAAAAGACAATGTA
gi|627328        60 CTAAATGATATACGATTCCACTA...
\end{minted}
If you are not interested in the metadata, then it is more convenient to use the \verb|Align.read| function, as anyway each Clustal file contains only one alignment:
%cont-doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignment = Align.read("opuntia.aln", "clustal")
\end{minted}
The consensus line below each alignment block in the Clustal output file contains an asterisk if the sequence is conserved at each position. This information is stored in the \verb|column_annotations| attribute of the \verb|alignment|:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.column_annotations  # doctest: +ELLIPSIS
{'clustal_consensus': '******* **** **********************************...
\end{minted}
Printing the \verb|alignment| in \verb|clustal| format will show the sequence alignment, but does not include the metadata:
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "clustal"))  # doctest: +ELLIPSIS
gi|6273285|gb|AF191659.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273284|gb|AF191658.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273287|gb|AF191661.1|AF191      TATACATT...
\end{minted}
Writing the \verb|alignments| in \verb|clustal| format will include both the metadata and the sequence alignment:
%cont-doctest
\begin{minted}{pycon}
>>> from io import StringIO
>>> stream = StringIO()
>>> alignments.rewind()
>>> Align.write(alignments, stream, "clustal")
1
>>> print(stream.getvalue())  # doctest: +ELLIPSIS
CLUSTAL 2.1 multiple sequence alignment
<BLANKLINE>
<BLANKLINE>
gi|6273285|gb|AF191659.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273284|gb|AF191658.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273287|gb|AF191661.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273286|gb|AF191660.1|AF191      TATACATAAAAGAAG...
\end{minted}
Use an \verb|Alignments| (plural) object (see section \ref{subsec:align_writing}) if you are creating alignments by hand, and would like to include metadata information in the output.

\subsection{Stockholm}
\label{subsec:align_stockholm}

This is an example of a protein sequence alignment in the Stockholm file format used by PFAM:

\begin{minted}{text}
# STOCKHOLM 1.0
#=GF ID   7kD_DNA_binding
#=GF AC   PF02294.20
#=GF DE   7kD DNA-binding domain
#=GF AU   Mian N;0000-0003-4284-4749
#=GF AU   Bateman A;0000-0002-6982-4660
#=GF SE   Pfam-B_8148 (release 5.2)
#=GF GA   25.00 25.00;
#=GF TC   26.60 46.20;
#=GF NC   23.20 19.20;
#=GF BM   hmmbuild HMM.ann SEED.ann
#=GF SM   hmmsearch -Z 57096847 -E 1000 --cpu 4 HMM pfamseq
#=GF TP   Domain
#=GF CL   CL0049
#=GF RN   [1]
#=GF RM   3130377
#=GF RT   Microsequence analysis of DNA-binding proteins 7a, 7b, and 7e
#=GF RT   from the archaebacterium Sulfolobus acidocaldarius. 
#=GF RA   Choli T, Wittmann-Liebold B, Reinhardt R; 
#=GF RL   J Biol Chem 1988;263:7087-7093.
#=GF DR   INTERPRO; IPR003212;
#=GF DR   SCOP; 1sso; fa;
#=GF DR   SO; 0000417; polypeptide_domain;
#=GF CC   This family contains members of the hyper-thermophilic
#=GF CC   archaebacterium  7kD DNA-binding/endoribonuclease P2 family.
#=GF CC   There are five 7kD DNA-binding proteins, 7a-7e, found as
#=GF CC   monomers in the cell. Protein 7e shows the  tightest DNA-binding
#=GF CC   ability.
#=GF SQ   3
#=GS DN7_METS5/4-61   AC A4YEA2.1
#=GS DN7A_SACS2/3-61  AC P61991.2
#=GS DN7A_SACS2/3-61  DR PDB; 1SSO A; 2-60;
#=GS DN7A_SACS2/3-61  DR PDB; 1JIC A; 2-60;
#=GS DN7A_SACS2/3-61  DR PDB; 2CVR A; 2-60;
#=GS DN7A_SACS2/3-61  DR PDB; 1B4O A; 2-60;
#=GS DN7E_SULAC/3-60  AC P13125.2
DN7_METS5/4-61              KIKFKYKGQDLEVDISKVKKVWKVGKMVSFTYDD.NGKTGRGAVSEKDAPKELLNMIGK
DN7A_SACS2/3-61             TVKFKYKGEEKQVDISKIKKVWRVGKMISFTYDEGGGKTGRGAVSEKDAPKELLQMLEK
#=GR DN7A_SACS2/3-61  SS    EEEEESSSSEEEEETTTEEEEEESSSSEEEEEE-SSSSEEEEEEETTTS-CHHHHHHTT
DN7E_SULAC/3-60             KVRFKYKGEEKEVDTSKIKKVWRVGKMVSFTYDD.NGKTGRGAVSEKDAPKELMDMLAR
#=GC SS_cons                EEEEESSSSEEEEETTTEEEEEESSSSEEEEEE-SSSSEEEEEEETTTS-CHHHHHHTT
#=GC seq_cons               KVKFKYKGEEKEVDISKIKKVWRVGKMVSFTYDD.NGKTGRGAVSEKDAPKELLsMLuK
//
\end{minted}
This is the seed alignment for the 7kD\_DNA\_binding (PF02294.20) PFAM entry, downloaded from the InterPro website (\url{https://www.ebi.ac.uk/interpro/}). This version of the PFAM entry is also available in the Biopython source distribution as the file \verb+pfam2.seed.txt+ in the subdirectory \verb+Tests/Stockholm/+. We can load this file as follows:
%doctest ../Tests/Stockholm lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignment = Align.read("pfam2.seed.txt", "stockholm")
>>> alignment  # doctest: +ELLIPSIS
<Alignment object (3 rows x 59 columns) at ...>
\end{minted}

\noindent We can print out a summary of the alignment:

%cont-doctest
\begin{minted}{pycon}
>>> print(alignment)
DN7_METS5         0 KIKFKYKGQDLEVDISKVKKVWKVGKMVSFTYDD-NGKTGRGAVSEKDAPKELLNMIGK
DN7A_SACS         0 TVKFKYKGEEKQVDISKIKKVWRVGKMISFTYDEGGGKTGRGAVSEKDAPKELLQMLEK
DN7E_SULA         0 KVRFKYKGEEKEVDTSKIKKVWRVGKMVSFTYDD-NGKTGRGAVSEKDAPKELMDMLAR
<BLANKLINE>
DN7_METS5        58
DN7A_SACS        59
DN7E_SULA        58
<BLANKLINE>
\end{minted}

You could also call Python's built-in \verb|format| function on the alignment object to show it in a particular file format (see section~\ref{subsec:align_printing} for details), for example in the Stockholm format to regenerate the file:
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "stockholm"))
# STOCKHOLM 1.0
#=GF ID   7kD_DNA_binding
#=GF AC   PF02294.20
#=GF DE   7kD DNA-binding domain
#=GF AU   Mian N;0000-0003-4284-4749
#=GF AU   Bateman A;0000-0002-6982-4660
#=GF SE   Pfam-B_8148 (release 5.2)
#=GF GA   25.00 25.00;
#=GF TC   26.60 46.20;
#=GF NC   23.20 19.20;
#=GF BM   hmmbuild HMM.ann SEED.ann
#=GF SM   hmmsearch -Z 57096847 -E 1000 --cpu 4 HMM pfamseq
#=GF TP   Domain
#=GF CL   CL0049
#=GF RN   [1]
#=GF RM   3130377
#=GF RT   Microsequence analysis of DNA-binding proteins 7a, 7b, and 7e from
#=GF RT   the archaebacterium Sulfolobus acidocaldarius.
#=GF RA   Choli T, Wittmann-Liebold B, Reinhardt R;
#=GF RL   J Biol Chem 1988;263:7087-7093.
#=GF DR   INTERPRO; IPR003212;
#=GF DR   SCOP; 1sso; fa;
#=GF DR   SO; 0000417; polypeptide_domain;
#=GF CC   This family contains members of the hyper-thermophilic
#=GF CC   archaebacterium  7kD DNA-binding/endoribonuclease P2 family. There
#=GF CC   are five 7kD DNA-binding proteins, 7a-7e, found as monomers in the
#=GF CC   cell. Protein 7e shows the  tightest DNA-binding ability.
#=GF SQ   3
#=GS DN7_METS5/4-61   AC A4YEA2.1
#=GS DN7A_SACS2/3-61  AC P61991.2
#=GS DN7A_SACS2/3-61  DR PDB; 1SSO A; 2-60;
#=GS DN7A_SACS2/3-61  DR PDB; 1JIC A; 2-60;
#=GS DN7A_SACS2/3-61  DR PDB; 2CVR A; 2-60;
#=GS DN7A_SACS2/3-61  DR PDB; 1B4O A; 2-60;
#=GS DN7E_SULAC/3-60  AC P13125.2
DN7_METS5/4-61                  KIKFKYKGQDLEVDISKVKKVWKVGKMVSFTYDD.NGKTGRGAVSEKDAPKELLNMIGK
DN7A_SACS2/3-61                 TVKFKYKGEEKQVDISKIKKVWRVGKMISFTYDEGGGKTGRGAVSEKDAPKELLQMLEK
#=GR DN7A_SACS2/3-61  SS        EEEEESSSSEEEEETTTEEEEEESSSSEEEEEE-SSSSEEEEEEETTTS-CHHHHHHTT
DN7E_SULAC/3-60                 KVRFKYKGEEKEVDTSKIKKVWRVGKMVSFTYDD.NGKTGRGAVSEKDAPKELMDMLAR
#=GC SS_cons                    EEEEESSSSEEEEETTTEEEEEESSSSEEEEEE-SSSSEEEEEEETTTS-CHHHHHHTT
#=GC seq_cons                   KVKFKYKGEEKEVDISKIKKVWRVGKMVSFTYDD.NGKTGRGAVSEKDAPKELLsMLuK
//
<BLANKLINE>
\end{minted}
or alternatively as aligned FASTA (see section \ref{subsec:align_fasta}):
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "fasta"))
>DN7_METS5/4-61
KIKFKYKGQDLEVDISKVKKVWKVGKMVSFTYDD-NGKTGRGAVSEKDAPKELLNMIGK
>DN7A_SACS2/3-61
TVKFKYKGEEKQVDISKIKKVWRVGKMISFTYDEGGGKTGRGAVSEKDAPKELLQMLEK
>DN7E_SULAC/3-60
KVRFKYKGEEKEVDTSKIKKVWRVGKMVSFTYDD-NGKTGRGAVSEKDAPKELMDMLAR
<BLANKLINE>
\end{minted}
or in the PHYLIP format (see section~\ref{subsec:align_phylip}):
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "phylip"))
3 59
DN7_METS5/KIKFKYKGQDLEVDISKVKKVWKVGKMVSFTYDD-NGKTGRGAVSEKDAPKELLNMIGK
DN7A_SACS2TVKFKYKGEEKQVDISKIKKVWRVGKMISFTYDEGGGKTGRGAVSEKDAPKELLQMLEK
DN7E_SULACKVRFKYKGEEKEVDTSKIKKVWRVGKMVSFTYDD-NGKTGRGAVSEKDAPKELMDMLAR
<BLANKLINE>
\end{minted}
General information of the alignment is stored under the \verb+annotations+ attribute of the \verb+Alignment+ object, for example
%cont-doctest
\begin{minted}{pycon}
>>> alignment.annotations["identifier"]
'7kD_DNA_binding'
>>> alignment.annotations["clan"]
'CL0049'
>>> alignment.annotations["database references"]
[{'reference': 'INTERPRO; IPR003212;'}, {'reference': 'SCOP; 1sso; fa;'}, {'reference': 'SO; 0000417; polypeptide_domain;'}]
\end{minted}
The individual sequences in this alignment are stored under \verb|alignment.sequences| as \verb|SeqRecord|s, including any annotations associated with each sequence record:
%cont-doctest
\begin{minted}{pycon}
>>> for record in alignment.sequences:
...     print("%s %s %s" % (record.id, record.annotations["accession"], record.dbxrefs))
...
DN7_METS5/4-61 A4YEA2.1 []
DN7A_SACS2/3-61 P61991.2 ['PDB; 1SSO A; 2-60;', 'PDB; 1JIC A; 2-60;', 'PDB; 2CVR A; 2-60;', 'PDB; 1B4O A; 2-60;']
DN7E_SULAC/3-60 P13125.2 []
\end{minted}
The secondary structure of the second sequence (\verb+DN7A_SACS2/3-61+) is stored in the \verb+letter_annotations+ attribute of the \verb+SeqRecord+:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.sequences[0].letter_annotations
{}
>>> alignment.sequences[1].letter_annotations
{'secondary structure': 'EEEEESSSSEEEEETTTEEEEEESSSSEEEEEE-SSSSEEEEEEETTTS-CHHHHHHTT'}
>>> alignment.sequences[2].letter_annotations
{}
\end{minted}
The consensus sequence and secondary structure are associated with the sequence alignment as a whole, and are therefore stored in the \verb+column_annotations+ attribute of the \verb+Alignment+ object:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.column_annotations  # doctest: +NORMALIZE_WHITESPACE
{'consensus secondary structure': 'EEEEESSSSEEEEETTTEEEEEESSSSEEEEEE-SSSSEEEEEEETTTS-CHHHHHHTT',
 'consensus sequence': 'KVKFKYKGEEKEVDISKIKKVWRVGKMVSFTYDD.NGKTGRGAVSEKDAPKELLsMLuK'}
\end{minted}

\subsection{PHYLIP output files}
\label{subsec:align_phylip}

The PHYLIP format for sequence alignments is derived from the PHYLogeny Interference Package from Joe Felsenstein. Files in the PHYLIP format start with two numbers for the number of rows and columns in the printed alignment. The sequence alignment itself can be in sequential format or in interleaved format. An example of the former is the \verb|sequential.phy| file (provided in \verb+Tests/Phylip/+ in the Biopython source distribution):
\begin{minted}{text}
 3 384
CYS1_DICDI   -----MKVIL LFVLAVFTVF VSS------- --------RG IPPEEQ---- --------SQ 
             FLEFQDKFNK KY-SHEEYLE RFEIFKSNLG KIEELNLIAI NHKADTKFGV NKFADLSSDE 
             FKNYYLNNKE AIFTDDLPVA DYLDDEFINS IPTAFDWRTR G-AVTPVKNQ GQCGSCWSFS 
             TTGNVEGQHF ISQNKLVSLS EQNLVDCDHE CMEYEGEEAC DEGCNGGLQP NAYNYIIKNG 
             GIQTESSYPY TAETGTQCNF NSANIGAKIS NFTMIP-KNE TVMAGYIVST GPLAIAADAV 
             E-WQFYIGGV F-DIPCN--P NSLDHGILIV GYSAKNTIFR KNMPYWIVKN SWGADWGEQG 
             YIYLRRGKNT CGVSNFVSTS II-- 
ALEU_HORVU   MAHARVLLLA LAVLATAAVA VASSSSFADS NPIRPVTDRA ASTLESAVLG ALGRTRHALR 
             FARFAVRYGK SYESAAEVRR RFRIFSESLE EVRSTN---- RKGLPYRLGI NRFSDMSWEE 
             FQATRL-GAA QTCSATLAGN HLMRDA--AA LPETKDWRED G-IVSPVKNQ AHCGSCWTFS 
             TTGALEAAYT QATGKNISLS EQQLVDCAGG FNNF------ --GCNGGLPS QAFEYIKYNG 
             GIDTEESYPY KGVNGV-CHY KAENAAVQVL DSVNITLNAE DELKNAVGLV RPVSVAFQVI 
             DGFRQYKSGV YTSDHCGTTP DDVNHAVLAV GYGVENGV-- ---PYWLIKN SWGADWGDNG 
             YFKMEMGKNM CAIATCASYP VVAA 
CATH_HUMAN   ------MWAT LPLLCAGAWL LGV------- -PVCGAAELS VNSLEK---- --------FH 
             FKSWMSKHRK TY-STEEYHH RLQTFASNWR KINAHN---- NGNHTFKMAL NQFSDMSFAE 
             IKHKYLWSEP QNCSAT--KS NYLRGT--GP YPPSVDWRKK GNFVSPVKNQ GACGSCWTFS 
             TTGALESAIA IATGKMLSLA EQQLVDCAQD FNNY------ --GCQGGLPS QAFEYILYNK 
             GIMGEDTYPY QGKDGY-CKF QPGKAIGFVK DVANITIYDE EAMVEAVALY NPVSFAFEVT 
             QDFMMYRTGI YSSTSCHKTP DKVNHAVLAV GYGEKNGI-- ---PYWIVKN SWGPQWGMNG 
             YFLIERGKNM CGLAACASYP IPLV
\end{minted}
In the sequential format, the complete alignment for one sequence is shown before proceeding to the next sequence. In the interleaved format, the alignments for different sequences are next to each other, for example in the file \verb|interlaced.phy| (provided in \verb+Tests/Phylip/+ in the Biopython source distribution):
\begin{minted}{text}
 3 384
CYS1_DICDI   -----MKVIL LFVLAVFTVF VSS------- --------RG IPPEEQ---- --------SQ 
ALEU_HORVU   MAHARVLLLA LAVLATAAVA VASSSSFADS NPIRPVTDRA ASTLESAVLG ALGRTRHALR 
CATH_HUMAN   ------MWAT LPLLCAGAWL LGV------- -PVCGAAELS VNSLEK---- --------FH 

             FLEFQDKFNK KY-SHEEYLE RFEIFKSNLG KIEELNLIAI NHKADTKFGV NKFADLSSDE 
             FARFAVRYGK SYESAAEVRR RFRIFSESLE EVRSTN---- RKGLPYRLGI NRFSDMSWEE 
             FKSWMSKHRK TY-STEEYHH RLQTFASNWR KINAHN---- NGNHTFKMAL NQFSDMSFAE 

             FKNYYLNNKE AIFTDDLPVA DYLDDEFINS IPTAFDWRTR G-AVTPVKNQ GQCGSCWSFS 
             FQATRL-GAA QTCSATLAGN HLMRDA--AA LPETKDWRED G-IVSPVKNQ AHCGSCWTFS 
             IKHKYLWSEP QNCSAT--KS NYLRGT--GP YPPSVDWRKK GNFVSPVKNQ GACGSCWTFS 

             TTGNVEGQHF ISQNKLVSLS EQNLVDCDHE CMEYEGEEAC DEGCNGGLQP NAYNYIIKNG 
             TTGALEAAYT QATGKNISLS EQQLVDCAGG FNNF------ --GCNGGLPS QAFEYIKYNG 
             TTGALESAIA IATGKMLSLA EQQLVDCAQD FNNY------ --GCQGGLPS QAFEYILYNK 

             GIQTESSYPY TAETGTQCNF NSANIGAKIS NFTMIP-KNE TVMAGYIVST GPLAIAADAV 
             GIDTEESYPY KGVNGV-CHY KAENAAVQVL DSVNITLNAE DELKNAVGLV RPVSVAFQVI 
             GIMGEDTYPY QGKDGY-CKF QPGKAIGFVK DVANITIYDE EAMVEAVALY NPVSFAFEVT 

             E-WQFYIGGV F-DIPCN--P NSLDHGILIV GYSAKNTIFR KNMPYWIVKN SWGADWGEQG 
             DGFRQYKSGV YTSDHCGTTP DDVNHAVLAV GYGVENGV-- ---PYWLIKN SWGADWGDNG 
             QDFMMYRTGI YSSTSCHKTP DKVNHAVLAV GYGEKNGI-- ---PYWIVKN SWGPQWGMNG 

             YIYLRRGKNT CGVSNFVSTS II-- 
             YFKMEMGKNM CAIATCASYP VVAA 
             YFLIERGKNM CGLAACASYP IPLV
\end{minted}
The parser in \verb|Bio.Align| detects from the file contents if it is in the sequential or in the interleaved format, and then parses it appropriately.
%doctest ../Tests/Phylip lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignment = Align.read("sequential.phy", "phylip")
>>> alignment  # doctest: +ELLIPSIS
<Alignment object (3 rows x 384 columns) at ...>
>>> alignment2 = Align.read("interlaced.phy", "phylip")
>>> alignment2  # doctest: +ELLIPSIS
<Alignment object (3 rows x 384 columns) at ...>
>>> alignment == alignment2
True
\end{minted}
Here, two alignments are considered to be equal if they have the same sequence contents and the same alignment coordinates.
%cont-doctest
\begin{minted}{pycon}
>>> alignment.shape
(3, 384)
>>> print(alignment)
CYS1_DICD         0 -----MKVILLFVLAVFTVFVSS---------------RGIPPEEQ------------SQ
ALEU_HORV         0 MAHARVLLLALAVLATAAVAVASSSSFADSNPIRPVTDRAASTLESAVLGALGRTRHALR
CATH_HUMA         0 ------MWATLPLLCAGAWLLGV--------PVCGAAELSVNSLEK------------FH
<BLANKLINE>
CYS1_DICD        28 FLEFQDKFNKKY-SHEEYLERFEIFKSNLGKIEELNLIAINHKADTKFGVNKFADLSSDE
ALEU_HORV        60 FARFAVRYGKSYESAAEVRRRFRIFSESLEEVRSTN----RKGLPYRLGINRFSDMSWEE
CATH_HUMA        34 FKSWMSKHRKTY-STEEYHHRLQTFASNWRKINAHN----NGNHTFKMALNQFSDMSFAE
<BLANKLINE>
CYS1_DICD        87 FKNYYLNNKEAIFTDDLPVADYLDDEFINSIPTAFDWRTRG-AVTPVKNQGQCGSCWSFS
ALEU_HORV       116 FQATRL-GAAQTCSATLAGNHLMRDA--AALPETKDWREDG-IVSPVKNQAHCGSCWTFS
CATH_HUMA        89 IKHKYLWSEPQNCSAT--KSNYLRGT--GPYPPSVDWRKKGNFVSPVKNQGACGSCWTFS
<BLANKLINE>
CYS1_DICD       146 TTGNVEGQHFISQNKLVSLSEQNLVDCDHECMEYEGEEACDEGCNGGLQPNAYNYIIKNG
ALEU_HORV       172 TTGALEAAYTQATGKNISLSEQQLVDCAGGFNNF--------GCNGGLPSQAFEYIKYNG
CATH_HUMA       145 TTGALESAIAIATGKMLSLAEQQLVDCAQDFNNY--------GCQGGLPSQAFEYILYNK
<BLANKLINE>
CYS1_DICD       206 GIQTESSYPYTAETGTQCNFNSANIGAKISNFTMIP-KNETVMAGYIVSTGPLAIAADAV
ALEU_HORV       224 GIDTEESYPYKGVNGV-CHYKAENAAVQVLDSVNITLNAEDELKNAVGLVRPVSVAFQVI
CATH_HUMA       197 GIMGEDTYPYQGKDGY-CKFQPGKAIGFVKDVANITIYDEEAMVEAVALYNPVSFAFEVT
<BLANKLINE>
CYS1_DICD       265 E-WQFYIGGVF-DIPCN--PNSLDHGILIVGYSAKNTIFRKNMPYWIVKNSWGADWGEQG
ALEU_HORV       283 DGFRQYKSGVYTSDHCGTTPDDVNHAVLAVGYGVENGV-----PYWLIKNSWGADWGDNG
CATH_HUMA       256 QDFMMYRTGIYSSTSCHKTPDKVNHAVLAVGYGEKNGI-----PYWIVKNSWGPQWGMNG
<BLANKLINE>
CYS1_DICD       321 YIYLRRGKNTCGVSNFVSTSII-- 343
ALEU_HORV       338 YFKMEMGKNMCAIATCASYPVVAA 362
CATH_HUMA       311 YFLIERGKNMCGLAACASYPIPLV 335
<BLANKLINE>
\end{minted}
When outputting the alignment in PHYLIP format, \verb|Bio.Align| writes each of the aligned sequences on one line:
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "phylip"))
3 384
CYS1_DICDI-----MKVILLFVLAVFTVFVSS---------------RGIPPEEQ------------SQFLEFQDKFNKKY-SHEEYLERFEIFKSNLGKIEELNLIAINHKADTKFGVNKFADLSSDEFKNYYLNNKEAIFTDDLPVADYLDDEFINSIPTAFDWRTRG-AVTPVKNQGQCGSCWSFSTTGNVEGQHFISQNKLVSLSEQNLVDCDHECMEYEGEEACDEGCNGGLQPNAYNYIIKNGGIQTESSYPYTAETGTQCNFNSANIGAKISNFTMIP-KNETVMAGYIVSTGPLAIAADAVE-WQFYIGGVF-DIPCN--PNSLDHGILIVGYSAKNTIFRKNMPYWIVKNSWGADWGEQGYIYLRRGKNTCGVSNFVSTSII--
ALEU_HORVUMAHARVLLLALAVLATAAVAVASSSSFADSNPIRPVTDRAASTLESAVLGALGRTRHALRFARFAVRYGKSYESAAEVRRRFRIFSESLEEVRSTN----RKGLPYRLGINRFSDMSWEEFQATRL-GAAQTCSATLAGNHLMRDA--AALPETKDWREDG-IVSPVKNQAHCGSCWTFSTTGALEAAYTQATGKNISLSEQQLVDCAGGFNNF--------GCNGGLPSQAFEYIKYNGGIDTEESYPYKGVNGV-CHYKAENAAVQVLDSVNITLNAEDELKNAVGLVRPVSVAFQVIDGFRQYKSGVYTSDHCGTTPDDVNHAVLAVGYGVENGV-----PYWLIKNSWGADWGDNGYFKMEMGKNMCAIATCASYPVVAA
CATH_HUMAN------MWATLPLLCAGAWLLGV--------PVCGAAELSVNSLEK------------FHFKSWMSKHRKTY-STEEYHHRLQTFASNWRKINAHN----NGNHTFKMALNQFSDMSFAEIKHKYLWSEPQNCSAT--KSNYLRGT--GPYPPSVDWRKKGNFVSPVKNQGACGSCWTFSTTGALESAIAIATGKMLSLAEQQLVDCAQDFNNY--------GCQGGLPSQAFEYILYNKGIMGEDTYPYQGKDGY-CKFQPGKAIGFVKDVANITIYDEEAMVEAVALYNPVSFAFEVTQDFMMYRTGIYSSTSCHKTPDKVNHAVLAVGYGEKNGI-----PYWIVKNSWGPQWGMNGYFLIERGKNMCGLAACASYPIPLV
<BLANKLINE>
\end{minted}
We can write the alignment in PHYLIP format, parse the result, and confirm it is the same as the original alignment object:
%cont-doctest
\begin{minted}{pycon}
>>> from io import StringIO
>>> stream = StringIO()
>>> Align.write(alignment, stream, "phylip")
1
>>> stream.seek(0)
0
>>> alignment3 = Align.read(stream, "phylip")
>>> alignment == alignment3
True
>>> [record.id for record in alignment.sequences]
['CYS1_DICDI', 'ALEU_HORVU', 'CATH_HUMAN']
>>> [record.id for record in alignment3.sequences]
['CYS1_DICDI', 'ALEU_HORVU', 'CATH_HUMAN']
\end{minted}

\subsection{EMBOSS}
\label{subsec:align_emboss}

\subsection{GSG Multiple Sequence Format (MSF)}
\label{subsec:align_msf}

\subsection{Exonerate}
\label{subsec:align_exonerate}

\subsection{Nexus}
\label{subsec:align_nexus}

\subsection{Tabular output from BLAST or FASTA}
\label{subsec:align_tabular}

\subsection{HH-suite output files}
\label{subsec:align_hhr}

\subsection{A2M}
\label{subsec:align_a2m}

\subsection{Mauve eXtended Multi-FastA (xmfa) format}
\label{subsec:align_mauve}

Mauve~\cite{darling2004} is a software package for constructing multiple genome alignments. These alignments are stored in the eXtended Multi-FastA (xmfa) format.
Depending on how exactly \verb|progressiveMauve| (the aligner program in Mauve) was called, the xmfa format is slightly different.

If \verb|progressiveMauve| is called with a single sequence input file, as in
\begin{minted}{text}
progressiveMauve combined.fasta  --output=combined.xmfa ...
\end{minted}
where \verb|combined.fasta| contains the genome sequences:
\begin{minted}{text}
>equCab1
GAAAAGGAAAGTACGGCCCGGCCACTCCGGGTGTGTGCTAGGAGGGCTTA
>mm9
GAAGAGGAAAAGTAGATCCCTGGCGTCCGGAGCTGGGACGT
>canFam2
CAAGCCCTGCGCGCTCAGCCGGAGTGTCCCGGGCCCTGCTTTCCTTTTC
\end{minted}
then the output file \verb|combined.xmfa| is as follows:
\begin{minted}{text}
#FormatVersion Mauve1
#Sequence1File	combined.fa
#Sequence1Entry	1
#Sequence1Format	FastA
#Sequence2File	combined.fa
#Sequence2Entry	2
#Sequence2Format	FastA
#Sequence3File	combined.fa
#Sequence3Entry	3
#Sequence3Format	FastA
#BackboneFile	combined.xmfa.bbcols
> 1:2-49 - combined.fa
AAGCCCTCCTAGCACACACCCGGAGTGG-CCGGGCCGTACTTTCCTTTT
> 2:0-0 + combined.fa
-------------------------------------------------
> 3:2-48 + combined.fa
AAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGCTTTCCTTTT
=
> 1:1-1 + combined.fa
G
=
> 1:50-50 + combined.fa
A
=
> 2:1-41 + combined.fa
GAAGAGGAAAAGTAGATCCCTGGCGTCCGGAGCTGGGACGT
=
> 3:1-1 + combined.fa
C
=
> 3:49-49 + combined.fa
C
=
\end{minted}
with numbers (1, 2, 3) referring to the input genome sequences for horse (\verb+equCab1+), mouse (\verb+mm9+), and dog (\verb+canFam2+), respectively.
This xmfa file consists of six alignment blocks, separated by \verb|=| characters. Use \verb|Align.parse| to extract these alignments:
%doctest ../Tests/Mauve lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.parse("combined.xmfa", "mauve")
\end{minted}
The file header data are stored in the \verb|metadata| attribute:
%cont-doctest
\begin{minted}{pycon}
>>> alignments.metadata  # doctest: +NORMALIZE_WHITESPACE
{'FormatVersion': 'Mauve1',
 'BackboneFile': 'combined.xmfa.bbcols',
 'File': 'combined.fa'}
\end{minted}
The \verb|identifiers| attribute stores the sequence identifiers for the three sequences, which in this case is the three numbers:
%cont-doctest
\begin{minted}{pycon}
>>> alignments.identifiers
['0', '1', '2']
\end{minted}
These identifiers are used in the individual alignments:
%cont-doctest
\begin{minted}{pycon}
>>> for alignment in alignments:
...     print([record.id for record in alignment.sequences])
...     print(alignment)
...     print("******")
...
['0', '1', '2']
0                49 AAGCCCTCCTAGCACACACCCGGAGTGG-CCGGGCCGTACTTTCCTTTT  1
1                 0 -------------------------------------------------  0
2                 1 AAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGCTTTCCTTTT 48
<BLANKLINE>
******
['0']
0                 0 G 1
<BLANKLINE>
******
['0']
0                49 A 50
<BLANKLINE>
******
['1']
1                 0 GAAGAGGAAAAGTAGATCCCTGGCGTCCGGAGCTGGGACGT 41
<BLANKLINE>
******
['2']
2                 0 C 1
<BLANKLINE>
******
['2']
2                48 C 49
<BLANKLINE>
******
\end{minted}
Note that only the first block is a real alignment; the other blocks contain only a single sequence. By including these blocks, the xmfa file contains the full sequence that was provided in the \verb|combined.fa| input file.

If \verb|progressiveMauve| is called with a separate input file for each genome, as in
\begin{minted}{text}
progressiveMauve equCab1.fa canFam2.fa mm9.fa --output=separate.xmfa ...
\end{minted}
where each Fasta file contains the genome sequence for one species only, then the output file \verb|separate.xmfa| is as follows:
\begin{minted}{text}
#FormatVersion Mauve1
#Sequence1File	equCab1.fa
#Sequence1Format	FastA
#Sequence2File	canFam2.fa
#Sequence2Format	FastA
#Sequence3File	mm9.fa
#Sequence3Format	FastA
#BackboneFile	separate.xmfa.bbcols
> 1:1-50 - equCab1.fa
TAAGCCCTCCTAGCACACACCCGGAGTGGCC-GGGCCGTAC-TTTCCTTTTC
> 2:1-49 + canFam2.fa
CAAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGC-TTTCCTTTTC
> 3:1-19 - mm9.fa
---------------------------------GGATCTACTTTTCCTCTTC
=
> 3:20-41 + mm9.fa
CTGGCGTCCGGAGCTGGGACGT
=
\end{minted}
The identifiers \verb+equCab1+ for horse, \verb+mm9+ for mouse, and \verb+canFam2+ for dog are now shown explicitly in the output file.
This xmfa file consists of two alignment blocks, separated by \verb|=| characters. Use \verb|Align.parse| to extract these alignments:
%doctest ../Tests/Mauve lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.parse("separate.xmfa", "mauve")
\end{minted}
The file header data now does not include the input file name:
%cont-doctest
\begin{minted}{pycon}
>>> alignments.metadata  # doctest: +NORMALIZE_WHITESPACE
{'FormatVersion': 'Mauve1',
 'BackboneFile': 'separate.xmfa.bbcols'}
\end{minted}
The \verb|identifiers| attribute stores the sequence identifiers for the three sequences:
%cont-doctest
\begin{minted}{pycon}
>>> alignments.identifiers
['equCab1.fa', 'canFam2.fa', 'mm9.fa']
\end{minted}
These identifiers are used in the individual alignments:
%cont-doctest
\begin{minted}{pycon}
>>> for alignment in alignments:
...     print([record.id for record in alignment.sequences])
...     print(alignment)
...     print("******")
...
['equCab1.fa', 'canFam2.fa', 'mm9.fa']
equCab1.f        50 TAAGCCCTCCTAGCACACACCCGGAGTGGCC-GGGCCGTAC-TTTCCTTTTC  0
canFam2.f         0 CAAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGC-TTTCCTTTTC 49
mm9.fa           19 ---------------------------------GGATCTACTTTTCCTCTTC  0
<BLANKLINE>
******
['mm9.fa']
mm9.fa           19 CTGGCGTCCGGAGCTGGGACGT 41
<BLANKLINE>
******
\end{minted}

To print the alignments in Mauve format, use \verb|Align.write|:
%cont-doctest
\begin{minted}{pycon}
>>> from io import StringIO
>>> stream = StringIO()
>>> alignments = Align.parse("separate.xmfa", "mauve")
>>> Align.write(alignments, stream, "mauve")
2
>>> print(stream.getvalue())  # doctest: +NORMALIZE_WHITESPACE
#FormatVersion Mauve1
#Sequence1File	equCab1.fa
#Sequence1Format	FastA
#Sequence2File	canFam2.fa
#Sequence2Format	FastA
#Sequence3File	mm9.fa
#Sequence3Format	FastA
#BackboneFile	separate.xmfa.bbcols
> 1:1-50 - equCab1.fa
TAAGCCCTCCTAGCACACACCCGGAGTGGCC-GGGCCGTAC-TTTCCTTTTC
> 2:1-49 + canFam2.fa
CAAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGC-TTTCCTTTTC
> 3:1-19 - mm9.fa
---------------------------------GGATCTACTTTTCCTCTTC
=
> 3:20-41 + mm9.fa
CTGGCGTCCGGAGCTGGGACGT
=
<BLANKLINE>
\end{minted}
Here, the writer makes use of the information stored in \verb+alignments.metadata+ and \verb+alignments.identifiers+ to create this format.
If your \verb|alignments| object does not have these attributes, you can provide them as keyword arguments to \verb+Align.write+:
%cont-doctest
\begin{minted}{pycon}
>>> stream = StringIO()
>>> alignments = Align.parse("separate.xmfa", "mauve")
>>> metadata = alignments.metadata
>>> identifiers = alignments.identifiers
>>> alignments = list(alignments)  # this drops the attributes
>>> alignments.metadata  # doctest: +ELLIPSIS
Traceback (most recent call last):
 ...
AttributeError: 'list' object has no attribute 'metadata'
>>> alignments.identifiers  # doctest: +ELLIPSIS
Traceback (most recent call last):
 ...
AttributeError: 'list' object has no attribute 'identifiers'
>>> Align.write(alignments, stream, "mauve", metadata=metadata, identifiers=identifiers)
2
>>> print(stream.getvalue())  # doctest: +NORMALIZE_WHITESPACE
#FormatVersion Mauve1
#Sequence1File	equCab1.fa
#Sequence1Format	FastA
#Sequence2File	canFam2.fa
#Sequence2Format	FastA
#Sequence3File	mm9.fa
#Sequence3Format	FastA
#BackboneFile	separate.xmfa.bbcols
> 1:1-50 - equCab1.fa
TAAGCCCTCCTAGCACACACCCGGAGTGGCC-GGGCCGTAC-TTTCCTTTTC
> 2:1-49 + canFam2.fa
CAAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGC-TTTCCTTTTC
> 3:1-19 - mm9.fa
---------------------------------GGATCTACTTTTCCTCTTC
=
> 3:20-41 + mm9.fa
CTGGCGTCCGGAGCTGGGACGT
=
<BLANKLINE>
\end{minted}
Python does not allow you to add these attributes to the \verb+alignments+ object directly, as in this example it was converted to a plain list.
However, you can construct an \verb|Alignments| object (which inherits from \verb+list+) and add the attributes to it:
%cont-doctest
\begin{minted}{pycon}
>>> alignments = Align.Alignments(alignments)
>>> alignments.metadata = metadata
>>> alignments.identifiers = identifiers
>>> stream = StringIO()
>>> Align.write(alignments, stream, "mauve", metadata=metadata, identifiers=identifiers)
2
>>> print(stream.getvalue())  # doctest: +NORMALIZE_WHITESPACE
#FormatVersion Mauve1
#Sequence1File	equCab1.fa
#Sequence1Format	FastA
#Sequence2File	canFam2.fa
#Sequence2Format	FastA
#Sequence3File	mm9.fa
#Sequence3Format	FastA
#BackboneFile	separate.xmfa.bbcols
> 1:1-50 - equCab1.fa
TAAGCCCTCCTAGCACACACCCGGAGTGGCC-GGGCCGTAC-TTTCCTTTTC
> 2:1-49 + canFam2.fa
CAAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGC-TTTCCTTTTC
> 3:1-19 - mm9.fa
---------------------------------GGATCTACTTTTCCTCTTC
=
> 3:20-41 + mm9.fa
CTGGCGTCCGGAGCTGGGACGT
=
<BLANKLINE>
\end{minted}
When printing a single alignment in \verb+Mauve+ format, use keyword arguments to provide the metadata and identifiers:
%cont-doctest
\begin{minted}{pycon}
>>> alignment = alignments[0]
>>> print(alignment.format("mauve", metadata=metadata, identifiers=identifiers))
> 1:1-50 - equCab1.fa
TAAGCCCTCCTAGCACACACCCGGAGTGGCC-GGGCCGTAC-TTTCCTTTTC
> 2:1-49 + canFam2.fa
CAAGCCCTGC--GCGCTCAGCCGGAGTGTCCCGGGCCCTGC-TTTCCTTTTC
> 3:1-19 - mm9.fa
---------------------------------GGATCTACTTTTCCTCTTC
=
<BLANKLINE>
\end{minted}

\subsection{Sequence Alignment/Map (SAM)}
\label{subseq:align_sam}

Files in the Sequence Alignment/Map (SAM) format \cite{li2009} store pairwise sequence alignments, usually of next-generation sequencing data against a reference genome. The file \verb+ex1.sam+ in Biopython's test suite is an example of a minimal file in the SAM format. Its first few lines are as follows:
\begin{minted}{text}
EAS56_57:6:190:289:82   69      chr1    100     0       *       =       100     0       CTCAAGGTTGTTGCAAGGGGGTCTATGTGAACAAA     <<<7<<<;<<<<<<<<8;;<7;4<;<;;;;;94<;     MF:i:192
EAS56_57:6:190:289:82   137     chr1    100     73      35M     =       100     0       AGGGGTGCAGAGCCGAGTCACGGGGTTGCCAGCAC     <<<<<<;<<<<<<<<<<;<<;<<<<;8<6;9;;2;     MF:i:64 Aq:i:0  NM:i:0  UQ:i:0  H0:i:1  H1:i:0
EAS51_64:3:190:727:308  99      chr1    103     99      35M     =       263     195     GGTGCAGAGCCGAGTCACGGGGTTGCCAGCACAGG     <<<<<<<<<<<<<<<<<<<<<<<<<<<::<<<844     MF:i:18 Aq:i:73 NM:i:0  UQ:i:0  H0:i:1  H1:i:0
...
\end{minted}
To parse this file, use
%doctest ../Tests/SamBam lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.parse("ex1.sam", "sam")
>>> alignment = next(alignments)
\end{minted}
The \verb|flag| of the first line is 69. According to the SAM/BAM file format specification, lines for which the flag contains the bitwise flag 4 are unmapped. As 69 has the bit corresponding to this position set to True, this sequence is unmapped and was not aligned to the genome (in spite of the first line showing \verb|chr1|). The target of this alignment (or the first item in \verb|alignment.sequences|) is therefore \verb|None|:
%cont-doctest
\begin{minted}{pycon}
>>> alignment.flag
69
>>> bin(69)
'0b1000101'
>>> bin(4)
'0b100'
>>> if alignment.flag & 4:
...     print("unmapped")
... else:
...     print("mapped")
...
unmapped
>>> alignment.sequences
[None, SeqRecord(seq=Seq('CTCAAGGTTGTTGCAAGGGGGTCTATGTGAACAAA'), id='EAS56_57:6:190:289:82', name='<unknown name>', description='', dbxrefs=[])]
>>> alignment.target is None
True
\end{minted}
The second line represents an alignment to chromosome 1:
%cont-doctest
\begin{minted}{pycon}
>>> alignment = next(alignments)
>>> if alignment.flag & 4:
...     print("unmapped")
... else:
...     print("mapped")
...
mapped
>>> alignment.target
SeqRecord(seq=None, id='chr1', name='<unknown name>', description='', dbxrefs=[])
\end{minted}
As this SAM file does not store the genome sequence information for each alignment, we cannot print the alignment. However, we can print the alignment information in SAM format or any other format (such as BED, see section~\ref{subsec:align_bed}) that does not require the target sequence information:
%cont-doctest
\begin{minted}{pycon}
>>> format(alignment, "sam")
'EAS56_57:6:190:289:82\t137\tchr1\t100\t73\t35M\t=\t100\t0\tAGGGGTGCAGAGCCGAGTCACGGGGTTGCCAGCAC\t<<<<<<;<<<<<<<<<<;<<;<<<<;8<6;9;;2;\tMF:i:64\tAq:i:0\tNM:i:0\tUQ:i:0\tH0:i:1\tH1:i:0\n'
>>> format(alignment, "bed")
'chr1\t99\t134\tEAS56_57:6:190:289:82\t0\t+\t99\t134\t0\t1\t35,\t0,\n'
\end{minted}
However, we cannot print the alignment in PSL format (see section~\ref{subsec:align_psl}) as that would require knowing the size of the target sequence chr1:
%cont-doctest
\begin{minted}{pycon}
>>> format(alignment, "psl")  # doctest: +ELLIPSIS
Traceback (most recent call last):
 ...
TypeError: ...
\end{minted}
If you know the size of the target sequences, you can set them by hand:
%cont-doctest
\begin{minted}{pycon}
>>> from Bio.Seq import Seq
>>> from Bio.SeqRecord import SeqRecord
>>> target = SeqRecord(Seq(None, length=1575), id="chr1")
>>> alignment.target = target
>>> format(alignment, "psl")  # doctest: +ELLIPSIS
'35\t0\t0\t0\t0\t0\t0\t0\t+\tEAS56_57:6:190:289:82\t35\t0\t35\tchr1\t1575\t99\t134\t1\t35,\t0,\t99,\n'
\end{minted}

The file \verb+ex1_header.sam+ in Biopython's test suite contains the same alignments, but now also includes a header. Its first few lines are as follows:
\begin{minted}{text}
@HD\tVN:1.3\tSO:coordinate
@SQ\tSN:chr1\tLN:1575
@SQ\tSN:chr2\tLN:1584
EAS56_57:6:190:289:82   69      chr1    100     0       *       =       100     0       CTCAAGGTTGTTGCAAGGGGGTCTATGTGAACAAA     <<<7<<<;<<<<<<<<8;;<7;4<;<;;;;;94<;     MF:i:192
...
\end{minted}
The header stores general information about the alignments, including the size of the target chromosomes. The target information is stored in the \verb|targets| attribute of the \verb|alignments| object:
%doctest ../Tests/SamBam lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.parse("ex1_header.sam", "sam")
>>> len(alignments.targets)
2
>>> alignments.targets[0]
SeqRecord(seq=Seq(None, length=1575), id='chr1', name='<unknown name>', description='', dbxrefs=[])
>>> alignments.targets[1]
SeqRecord(seq=Seq(None, length=1584), id='chr2', name='<unknown name>', description='', dbxrefs=[])
\end{minted}
Other information provided in the header is stored in the \verb|metadata| attribute:
%cont-doctest
\begin{minted}{pycon}
>>> alignments.metadata
{'HD': {'VN': '1.3', 'SO': 'coordinate'}}
\end{minted}
With the target information, we can now also print the alignment in PSL format:
%cont-doctest
\begin{minted}{pycon}
>>> alignment = next(alignments)  # the unmapped sequence; skip it
>>> alignment = next(alignments)
>>> format(alignment, "psl")
'35\t0\t0\t0\t0\t0\t0\t0\t+\tEAS56_57:6:190:289:82\t35\t0\t35\tchr1\t1575\t99\t134\t1\t35,\t0,\t99,\n'
\end{minted}
We can now also print the alignment in human-readable form, but note that the target sequence contents is not available from this file:
%cont-doctest
\begin{minted}{pycon}
>>> print(alignment)
chr1             99 ??????????????????????????????????? 134
                  0 ...................................  35
EAS56_57:         0 AGGGGTGCAGAGCCGAGTCACGGGGTTGCCAGCAC  35
<BLANKLINE>
\end{minted}
Alignments in the file \verb|sam1.sam| in the Biopython test suite contain an additional \verb+MD+ tag that shows how the query sequence differs from the target sequence:
\begin{minted}{text}
@SQ     SN:1    LN:239940
@PG     ID:bwa  PN:bwa  VN:0.6.2-r126
HWI-1KL120:88:D0LRBACXX:1:1101:1780:2146        77      *       0       0       *       *       0       0       GATGGGAAACCCATGGCCGAGTGGGAAGAAACCAGCTGAGGTCACATCACCAGAGGAGGGAGAGTGTGGCCCCTGACTCAGTCCATCAGCTTGTGGAGCTG   @=?DDDDBFFFF7A;E?GGEGE8BB?FF?F>G@F=GIIDEIBCFF<FEFEC@EEEE2?8B8/=@((-;?@2<B9@##########################
...
HWI-1KL120:88:D0LRBACXX:1:1101:2852:2134        137     1       136186  25      101M    =       136186  0       TCACGGTGGCCTGTTGAGGCAGGGGCTCACGCTGACCTCTCTCGGCGTGGGAGGGGCCGGTGTGAGGCAAGGGCTCACGCTGACCTCTCTCGGCGTGGGAG   @C@FFFDFHGHHHJJJIJJJJIJJJGEDHHGGHGBGIIGIIAB@GEE=BDBBCCDD@D@B7@;@DDD?<A?DD728:>8()009>:>>C@>5??B######   XT:A:U  NM:i:5  SM:i:25 AM:i:0  X0:i:1  X1:i:0  XM:i:5  XO:i:0  XG:i:0  MD:Z:25G14G2C34A12A9
\end{minted}
The parser reconstructs the local genome sequence from the \verb|MD| tag, allowing us to see the target sequence explicitly when printing the alignment:
%doctest ../Tests/SamBam lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> alignments = Align.parse("sam1.sam", "sam")
>>> for alignment in alignments:
...     if not alignment.flag & 4:  # Skip the unmapped lines
...         break
...
>>> alignment  # doctest: +ELLIPSIS
<Alignment object (2 rows x 101 columns) at ...>
>>> print(alignment)
1            136185 TCACGGTGGCCTGTTGAGGCAGGGGGTCACGCTGACCTCTGTCCGCGTGGGAGGGGCCGG
                  0 |||||||||||||||||||||||||.||||||||||||||.||.||||||||||||||||
HWI-1KL12         0 TCACGGTGGCCTGTTGAGGCAGGGGCTCACGCTGACCTCTCTCGGCGTGGGAGGGGCCGG
<BLANKLINE>
1            136245 TGTGAGGCAAGGGCTCACACTGACCTCTCTCAGCGTGGGAG 136286
                 60 ||||||||||||||||||.||||||||||||.|||||||||    101
HWI-1KL12        60 TGTGAGGCAAGGGCTCACGCTGACCTCTCTCGGCGTGGGAG    101
<BLANKLINE>
\end{minted}

To write a SAM file with alignments created from scratch, use an \verb|Alignments| (plural) object to store the alignments as well as the metadata and targets:
%doctest . lib:numpy
\begin{minted}{pycon}
>>> from io import StringIO
>>> import numpy as np

>>> from Bio import Align
>>> from Bio.Seq import Seq
>>> from Bio.SeqRecord import SeqRecord

>>> alignments = Align.Alignments()

>>> seq1 = Seq(None, length=10000)
>>> target1 = SeqRecord(seq1, id="chr1")
>>> seq2 = Seq(None, length=15000)
>>> target2 = SeqRecord(seq2, id="chr2")
>>> alignments.targets = [target1, target2]
>>> alignments.metadata = {"HD": {"VN": "1.3", "SO": "coordinate"}}

>>> seqA = Seq(None, length=20)
>>> queryA = SeqRecord(seqA, id="readA")
>>> sequences = [target1, queryA]
>>> coordinates = np.array([[4300, 4320], [0, 20]])
>>> alignment = Align.Alignment(sequences, coordinates)
>>> alignments.append(alignment)

>>> seqB = Seq(None, length=25)
>>> queryB = SeqRecord(seqB, id="readB")
>>> sequences = [target1, queryB]
>>> coordinates = np.array([[5900, 5925], [25, 0]])
>>> alignment = Align.Alignment(sequences, coordinates)
>>> alignments.append(alignment)

>>> seqC = Seq(None, length=40)
>>> queryC = SeqRecord(seqC, id="readC")
>>> sequences = [target2, queryC]
>>> coordinates = np.array([[12300, 12318], [0, 18]])
>>> alignment = Align.Alignment(sequences, coordinates)
>>> alignments.append(alignment)

>>> stream = StringIO()
>>> Align.write(alignments, stream, "sam")
3
>>> print(stream.getvalue())  # doctest: +NORMALIZE_WHITESPACE
@HD	VN:1.3	SO:coordinate
@SQ	SN:chr1	LN:10000
@SQ	SN:chr2	LN:15000
readA	0	chr1	4301	255	20M	*	0	0	*	*
readB	16	chr1	5901	255	25M	*	0	0	*	*
readC	0	chr2	12301	255	18M22S	*	0	0	*       *
<BLANKLINE>
\end{minted}

\subsection{Browser Extensible Data (BED)}
\label{subsec:align_bed}

Create a string representing the alignment in the Browser Extensible Data (BED) file format:
%doctest . lib:numpy
\begin{minted}{pycon}
>>> import numpy as np
>>> from Bio import Align
>>> from Bio.SeqUtils import gc_fraction
>>> seqA = "CGTTTTT"
>>> seqB = "CGATTTTT"
>>> seqC = "GTGGTTT"
>>> sequences = [seqA, seqB, seqC]
>>> coordinates = np.array([[0, 2, 2, 5, 7], [0, 2, 3, 6, 8], [1, 3, 4, 7, 7]])
>>> alignment = Align.Alignment(sequences, coordinates)
>>> alignment.sort(key=gc_fraction, reverse=True)
>>> alignment = alignment[:2]
>>> format(alignment, "bed")
'target\t1\t7\tquery\t0\t+\t1\t7\t0\t2\t2,3,\t0,3,\n'
\end{minted}

\subsection{bigBed}
\label{subsec:align_bigbed}

\subsection{Pattern Space Layout (PSL)}
\label{subsec:align_psl}

Create a string representing the alignment in the Pattern Space Layout (PSL) file format as generated by BLAT \cite{kent2002}).
%cont-doctest
\begin{minted}{pycon}
>>> alignment.format("psl")
'4\t1\t0\t0\t0\t0\t1\t1\t+\tquery\t7\t0\t5\ttarget\t7\t1\t7\t2\t2,3,\t0,2,\t1,4,\n'
\end{minted}
The first four columns in the PSL output contain the number of matched and mismatched characters, the number of matches to repeat regions, and the number of matches to unknown nucleotides.
Repeat regions in the target sequence are indicated by masking the sequence as lower-case or upper-case characters, as defined by the following values for the \verb+mask+ keyword argument:
\begin{itemize}
\item \verb+False+ (default): Do not count matches to masked sequences separately;
\item \verb+"lower"+: Count and report matches to lower-case characters as matches to repeat regions;
\item \verb+"upper"+: Count and report matches to upper-case characters as matches to repeat regions;
\end{itemize}
The character used for unknown nucleotides is defined by the \verb+wildcard+ argument. For consistency with BLAT, the wildcard character is \verb+"N"+ by default. Use \verb+wildcard=None+ if you don't want to count matches to any unknown nucleotides separately.
%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> aligner.mismatch_score = -1
>>> aligner.internal_gap_score = -5
>>> aligner.wildcard = "N"
>>> target = "AAAAAAAggggGGNGAAAAA"
>>> query = "GGTGGGGG"
>>> alignments = aligner.align(target.upper(), query)
>>> len(alignments)
1
>>> alignment = alignments[0]
>>> print(alignment)
target            0 AAAAAAAGGGGGGNGAAAAA 20
                  0 -------||.|||.|----- 20
query             0 -------GGTGGGGG-----  8
<BLANKLINE>
>>> alignment.score
5.0
>>> alignment.target
'AAAAAAAGGGGGGNGAAAAA'
>>> alignment.target = target
>>> alignment.target
'AAAAAAAggggGGNGAAAAA'
>>> print(alignment)
target            0 AAAAAAAggggGGNGAAAAA 20
                  0 -------....||.|----- 20
query             0 -------GGTGGGGG-----  8
<BLANKLINE>
>>> print(alignment.format("psl"))  # doctest: +NORMALIZE_WHITESPACE
6   1   0   1   0   0   0   0   +   query   8   0   8   target   20   7   15   1   8,   0,   7,
>>> print(alignment.format("psl", mask="lower"))  # doctest: +NORMALIZE_WHITESPACE
3   1   3   1   0   0   0   0   +   query   8   0   8   target   20   7   15   1   8,   0,   7,
>>> print(
...     alignment.format("psl", mask="lower", wildcard=None)
... )  # doctest: +NORMALIZE_WHITESPACE
3   2   3   0   0   0   0   0   +   query   8   0   8   target   20   7   15   1   8,   0,   7,
\end{minted}

In addition to the \verb+format+ method, you can use Python's built-in \verb+format+ function:
%cont-doctest
\begin{minted}{pycon}
>>> print(format(alignment, "psl"))  # doctest: +NORMALIZE_WHITESPACE
6   1   0   1   0   0   0   0   +   query   8   0   8   target   20   7   15   1   8,   0,   7,
\end{minted}
allowing \verb+Alignment+ objects to be used in formatted (f-) strings in Python:
\begin{minted}{pycon}
>>> print(
...     f"The alignment in PSL format is '{alignment:psl}'."
... )  # doctest: +NORMALIZE_WHITESPACE
The alignment in PSL format is '6   1   0   1   0   0   0   0   +   query   8   0   8   target   20   7   15   1   8,   0,   7,
'
\end{minted}
Note that optional keyword arguments cannot be used with the \verb+format+ function or with formatted strings.

\subsection{bigPsl}
\label{subsec:align_bigpsl}

\subsection{Multiple Alignment Format (MAF)}
\label{subsec:align_maf}

\subsection{bigMaf}
\label{subsec:align_bigmaf}

\section{Substitution matrices}
\label{sec:substitution_matrices}

Substitution matrices \cite{durbin1998} provide the scoring terms for classifying how likely two different residues are to substitute for each other. This is essential in doing sequence comparisons.  Biopython provides a ton of common substitution matrices, including the famous PAM and BLOSUM series of matrices, and also provides functionality for creating your own substitution matrices.

\subsection{Array objects}

You can think of substitutions matrices as 2D arrays in which the indices are letters (nucleotides or amino acids) rather than integers.  The \verb+Array+ class in \verb+Bio.Align.substitution_matrices+ is a subclass of numpy arrays that supports indexing both by integers and by specific strings. An \verb+Array+ instance can either be a one-dimensional array or a square two-dimensional arrays. A one-dimensional \verb+Array+ object can for example be used to store the nucleotide frequency of a DNA sequence, while a two-dimensional \verb+Array+ object can be used to represent a scoring matrix for sequence alignments.

To create a one-dimensional \verb+Array+, only the alphabet of allowed letters needs to be specified:

%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align.substitution_matrices import Array
>>> counts = Array("ACGT")
>>> print(counts)
A 0.0
C 0.0
G 0.0
T 0.0
<BLANKLINE>
\end{minted}
The allowed letters are stored in the \verb+alphabet+ property:

%cont-doctest
\begin{minted}{pycon}
>>> counts.alphabet
'ACGT'
\end{minted}
This property is read-only; modifying the underlying \verb+_alphabet+ attribute may lead to unexpected results.
Elements can be accessed both by letter and by integer index:

%cont-doctest
\begin{minted}{pycon}
>>> counts["C"] = -3
>>> counts[2] = 7
>>> print(counts)
A  0.0
C -3.0
G  7.0
T  0.0
<BLANKLINE>
>>> counts[1]
-3.0
\end{minted}

Using a letter that is not in the alphabet, or an index that is out of bounds, will cause a \verb+IndexError+:

%cont-doctest
\begin{minted}{pycon}
>>> counts["U"]
Traceback (most recent call last):
    ...
IndexError: 'U'
>>> counts["X"] = 6
Traceback (most recent call last):
    ...
IndexError: 'X'
>>> counts[7]
Traceback (most recent call last):
    ...
IndexError: index 7 is out of bounds for axis 0 with size 4
\end{minted}

A two-dimensional \verb+Array+ can be created by specifying \verb+dims=2+:

%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align.substitution_matrices import Array
>>> counts = Array("ACGT", dims=2)
>>> print(counts)
    A   C   G   T
A 0.0 0.0 0.0 0.0
C 0.0 0.0 0.0 0.0
G 0.0 0.0 0.0 0.0
T 0.0 0.0 0.0 0.0
<BLANKLINE>
\end{minted}
Again, both letters and integers can be used for indexing, and specifying a letter that is not in the alphabet will cause an \verb+IndexError+:

%cont-doctest
\begin{minted}{pycon}
>>> counts["A", "C"] = 12.0
>>> counts[2, 1] = 5.0
>>> counts[3, "T"] = -2
>>> print(counts)
    A    C   G    T
A 0.0 12.0 0.0  0.0
C 0.0  0.0 0.0  0.0
G 0.0  5.0 0.0  0.0
T 0.0  0.0 0.0 -2.0
<BLANKLINE>
>>> counts["X", 1]
Traceback (most recent call last):
    ...
IndexError: 'X'
>>> counts["A", 5]
Traceback (most recent call last):
    ...
IndexError: index 5 is out of bounds for axis 1 with size 4
\end{minted}
Selecting a row or column from the two-dimensional array will return a one-dimensional \verb+Array+:

%cont-doctest
\begin{minted}{pycon}
>>> counts = Array("ACGT", dims=2)
>>> counts["A", "C"] = 12.0
>>> counts[2, 1] = 5.0
>>> counts[3, "T"] = -2
\end{minted}
% don't include this in the doctest, as the exact output is platform-dependent
\begin{minted}{pycon}
>>> counts["G"]
Array([0., 5., 0., 0.],
      alphabet='ACGT')
>>> counts[:, "C"]
Array([12.,  0.,  5.,  0.],
      alphabet='ACGT')
\end{minted}

\verb+Array+ objects can thus be used as an array and as a dictionary. They can be converted to plain numpy arrays or plain dictionary objects:

%cont-doctest
\begin{minted}{pycon}
>>> import numpy as np
>>> x = Array("ACGT")
>>> x["C"] = 5
\end{minted}
% don't include this in the doctest, as the exact output is platform-dependent
\begin{minted}{pycon}
>>> x
Array([0., 5., 0., 0.],
      alphabet='ACGT')
>>> a = np.array(x)  # create a plain numpy array
>>> a
array([0., 5., 0., 0.])
>>> d = dict(x)  # create a plain dictionary
>>> d
{'A': 0.0, 'C': 5.0, 'G': 0.0, 'T': 0.0}
\end{minted}

While the alphabet of an \verb+Array+ is usually a string, you may also use a tuple of (immutable) objects. This is used for example for a \hyperlink{codonmatrix}{codon substitution matrix}, where the keys are not individual nucleotides or amino acids but instead three-nucleotide codons.

While the \verb+alphabet+ property of an \verb+Array+ is immutable, you can create a new \verb+Array+ object by selecting the letters you are interested in from the alphabet. For example,
%cont-doctest
\begin{minted}{pycon}
>>> a = Array("ABCD", dims=2, data=np.arange(16).reshape(4, 4))
>>> print(a)
     A    B    C    D
A  0.0  1.0  2.0  3.0
B  4.0  5.0  6.0  7.0
C  8.0  9.0 10.0 11.0
D 12.0 13.0 14.0 15.0
<BLANKLINE>
>>> b = a.select("CAD")
>>> print(b)
     C    A    D
C 10.0  8.0 11.0
A  2.0  0.0  3.0
D 14.0 12.0 15.0
<BLANKLINE>
\end{minted}
Note that this also allows you to reorder the alphabet.

Data for letters that are not found in the alphabet are set to zero:
%cont-doctest
\begin{minted}{pycon}
>>> c = a.select("DEC")
>>> print(c)
     D   E    C
D 15.0 0.0 14.0
E  0.0 0.0  0.0
C 11.0 0.0 10.0
<BLANKLINE>
\end{minted}

As the \verb+Array+ class is a subclass of numpy array, it can be used as such. A \verb+ValueError+ is triggered if the \verb+Array+ objects appearing in a mathematical operation have different alphabets, for example

%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align.substitution_matrices import Array
>>> d = Array("ACGT")
>>> r = Array("ACGU")
>>> d + r
Traceback (most recent call last):
    ...
ValueError: alphabets are inconsistent
\end{minted}

\subsection{Calculating a substitution matrix from a pairwise sequence alignment}

As \verb+Array+ is a subclass of a numpy array, you can apply mathematical operations on an \verb+Array+ object in much the same way. Here, we illustrate this by calculating a scoring matrix from the alignment of the 16S ribosomal RNA gene sequences of \textit{Escherichia coli} and \textit{Bacillus subtilis}. First, we create a \verb+PairwiseAligner+ object (see Chapter~\ref{chapter:pairwise}) and initialize it with the default scores used by \verb+blastn+:

%doctest ../Tests/Align lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align import PairwiseAligner
>>> aligner = PairwiseAligner(scoring="blastn")
>>> aligner.mode = "local"
\end{minted}
Next, we read in the 16S ribosomal RNA gene sequence of \textit{Escherichia coli} and \textit{Bacillus subtilis} (provided in \verb+Tests/Align/ecoli.fa+ and \verb+Tests/Align/bsubtilis.fa+), and align them to each other:

%cont-doctest
\begin{minted}{pycon}
>>> from Bio import SeqIO
>>> sequence1 = SeqIO.read("ecoli.fa", "fasta")
>>> sequence2 = SeqIO.read("bsubtilis.fa", "fasta")
>>> alignments = aligner.align(sequence1, sequence2)
\end{minted}
The number of alignments generated is very large:

%cont-doctest
\begin{minted}{pycon}
>>> len(alignments)
1990656
\end{minted}
However, as they only differ trivially from each other, we arbitrarily choose the first alignment, and count the number of each substitution:

%cont-doctest
\begin{minted}{pycon}
>>> alignment = alignments[0]
>>> substitutions = alignment.substitutions
>>> print(substitutions)
      A     C     G     T
A 307.0  19.0  34.0  19.0
C  15.0 280.0  25.0  29.0
G  34.0  24.0 401.0  20.0
T  24.0  36.0  20.0 228.0
<BLANKLINE>
\end{minted}
We normalize against the total number to find the probability of each substitution, and create a symmetric matrix of observed frequencies:

%cont-doctest
\begin{minted}{pycon}
>>> observed_frequencies = substitutions / substitutions.sum()
>>> observed_frequencies = (observed_frequencies + observed_frequencies.transpose()) / 2.0
>>> print(format(observed_frequencies, "%.4f"))
       A      C      G      T
A 0.2026 0.0112 0.0224 0.0142
C 0.0112 0.1848 0.0162 0.0215
G 0.0224 0.0162 0.2647 0.0132
T 0.0142 0.0215 0.0132 0.1505
<BLANKLINE>
\end{minted}
The background probability is the probability of finding an A, C, G, or T nucleotide in each sequence separately. This can be calculated as the sum of each row or column:

%cont-doctest
\begin{minted}{pycon}
>>> background = observed_frequencies.sum(0)
>>> print(format(background, "%.4f"))
A 0.2505
C 0.2337
G 0.3165
T 0.1993
<BLANKLINE>
\end{minted}
The number of substitutions expected at random is simply the product of the background distribution with itself:

%cont-doctest
\begin{minted}{pycon}
>>> expected_frequencies = background[:, None].dot(background[None, :])
>>> print(format(expected_frequencies, "%.4f"))
       A      C      G      T
A 0.0627 0.0585 0.0793 0.0499
C 0.0585 0.0546 0.0740 0.0466
G 0.0793 0.0740 0.1002 0.0631
T 0.0499 0.0466 0.0631 0.0397
<BLANKLINE>
\end{minted}
The scoring matrix can then be calculated as the logarithm of the odds-ratio of the observed and the expected probabilities:

%cont-doctest
\begin{minted}{pycon}
>>> oddsratios = observed_frequencies / expected_frequencies
>>> import numpy as np
>>> scoring_matrix = np.log2(oddsratios)
>>> print(scoring_matrix)
     A    C    G    T
A  1.7 -2.4 -1.8 -1.8
C -2.4  1.8 -2.2 -1.1
G -1.8 -2.2  1.4 -2.3
T -1.8 -1.1 -2.3  1.9
<BLANKLINE>
\end{minted}
The matrix can be used to set the substitution matrix for the pairwise aligner (see Chapter~\ref{chapter:pairwise}):

%cont-doctest
\begin{minted}{pycon}
>>> aligner.substitution_matrix = scoring_matrix
\end{minted}

\subsection{Calculating a substitution matrix from a multiple sequence alignment}
\label{sec:subs_mat_ex}

In this example, we'll first read a protein sequence alignment from the Clustalw file \href{examples/protein.aln}{protein.aln} (also available online
\href{https://raw.githubusercontent.com/biopython/biopython/master/Tests/Clustalw/protein.aln}{here})

%doctest ../Tests/Clustalw lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> filename = "protein.aln"
>>> alignment = Align.read(filename, "clustal")
\end{minted}

Section~\ref{subsec:align_clustal} contains more information on doing this.

The \verb+substitutions+ property of the alignment stores the number of times
different residues substitute for each other:
%cont-doctest
\begin{minted}{pycon}
>>> substitutions = alignment.substitutions
\end{minted}

To make the example more readable, we'll select only amino acids with polar charged side chains:

%cont-doctest
\begin{minted}{pycon}
>>> substitutions = substitutions.select("DEHKR")
>>> print(substitutions)
       D      E      H      K      R
D 2360.0  270.0   15.0    1.0   48.0
E  241.0 3305.0   15.0   45.0    2.0
H    0.0   18.0 1235.0    8.0    0.0
K    0.0    9.0   24.0 3218.0  130.0
R    2.0    2.0   17.0  103.0 2079.0
<BLANKLINE>
\end{minted}
Rows and columns for other amino acids were removed from the matrix.

Next, we normalize the matrix and make it symmetric.
%cont-doctest
\begin{minted}{pycon}
>>> observed_frequencies = substitutions / substitutions.sum()
>>> observed_frequencies = (observed_frequencies + observed_frequencies.transpose()) / 2.0
>>> print(format(observed_frequencies, "%.4f"))
       D      E      H      K      R
D 0.1795 0.0194 0.0006 0.0000 0.0019
E 0.0194 0.2514 0.0013 0.0021 0.0002
H 0.0006 0.0013 0.0939 0.0012 0.0006
K 0.0000 0.0021 0.0012 0.2448 0.0089
R 0.0019 0.0002 0.0006 0.0089 0.1581
<BLANKLINE>
\end{minted}

Summing over rows or columns gives the relative frequency of occurrence of
each residue:
%cont-doctest
\begin{minted}{pycon}
>>> background = observed_frequencies.sum(0)
>>> print(format(background, "%.4f"))
D 0.2015
E 0.2743
H 0.0976
K 0.2569
R 0.1697
<BLANKLINE>
>>> background.sum()
1.0
\end{minted}

The expected frequency of residue pairs is then
%cont-doctest
\begin{minted}{pycon}
>>> expected_frequencies = background[:, None].dot(background[None, :])
>>> print(format(expected_frequencies, "%.4f"))
       D      E      H      K      R
D 0.0406 0.0553 0.0197 0.0518 0.0342
E 0.0553 0.0752 0.0268 0.0705 0.0465
H 0.0197 0.0268 0.0095 0.0251 0.0166
K 0.0518 0.0705 0.0251 0.0660 0.0436
R 0.0342 0.0465 0.0166 0.0436 0.0288
<BLANKLINE>
\end{minted}
Here, \verb+background[:, None]+ creates a 2D array consisting of a single column with the values of \verb+expected_frequencies+, and \verb+rxpected_frequencies[None, :]+ a 2D array with these values as a single row. Taking their dot product (inner product) creates a matrix of expected frequencies where each entry consists of two \verb+expected_frequencies+ values multiplied with each other. For example, \verb+expected_frequencies['D', 'E']+ is equal to \verb+residue_frequencies['D'] * residue_frequencies['E']+.

We can now calculate the log-odds matrix by dividing the observed frequencies by the expected frequencies and taking the logarithm:
%cont-doctest
\begin{minted}{pycon}
>>> import numpy as np
>>> scoring_matrix = np.log2(observed_frequencies / expected_frequencies)
>>> print(scoring_matrix)
      D    E    H     K    R
D   2.1 -1.5 -5.1 -10.4 -4.2
E  -1.5  1.7 -4.4  -5.1 -8.3
H  -5.1 -4.4  3.3  -4.4 -4.7
K -10.4 -5.1 -4.4   1.9 -2.3
R  -4.2 -8.3 -4.7  -2.3  2.5
<BLANKLINE>
\end{minted}

This matrix can be used as the substitution matrix when performing alignments. For example,
%cont-doctest
\begin{minted}{pycon}
>>> from Bio.Align import PairwiseAligner
>>> aligner = PairwiseAligner()
>>> aligner.substitution_matrix = scoring_matrix
>>> aligner.gap_score = -3.0
>>> alignments = aligner.align("DEHEK", "DHHKK")
>>> print(alignments[0])
target            0 DEHEK 5
                  0 |.|.| 5
query             0 DHHKK 5
<BLANKLINE>
>>> print("%.2f" % alignments.score)
-2.18
>>> score = (
...     scoring_matrix["D", "D"]
...     + scoring_matrix["E", "H"]
...     + scoring_matrix["H", "H"]
...     + scoring_matrix["E", "K"]
...     + scoring_matrix["K", "K"]
... )
>>> print("%.2f" % score)
-2.18
\end{minted}
(see Chapter~\ref{chapter:pairwise} for details).

\subsection{Reading \texttt{Array} objects from file}

\verb+Bio.Align.substitution_matrices+ includes a parser to read one- and two-dimensional \verb+Array+ objects from file. One-dimensional arrays are represented by a simple two-column format, with the first column containing the key and the second column the corresponding value. For example, the file \verb+hg38.chrom.sizes+ (obtained from UCSC), available in the \verb+Tests/Align+ subdirectory of the Biopython distribution, contains the size in nucleotides of each chromosome in human genome assembly hg38:
\begin{minted}{text}
chr1    248956422
chr2    242193529
chr3    198295559
chr4    190214555
...
chrUn_KI270385v1    990
chrUn_KI270423v1    981
chrUn_KI270392v1    971
chrUn_KI270394v1    970
\end{minted}
To parse this file, use

%doctest ../Tests/Align lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align import substitution_matrices
>>> with open("hg38.chrom.sizes") as handle:
...     table = substitution_matrices.read(handle)
...
>>> print(table)  # doctest: +ELLIPSIS
chr1 248956422.0
chr2 242193529.0
chr3 198295559.0
chr4 190214555.0
...
chrUn_KI270423v1       981.0
chrUn_KI270392v1       971.0
chrUn_KI270394v1       970.0
<BLANKLINE>
\end{minted}
Use \verb+dtype=int+ to read the values as integers:

%cont-doctest
\begin{minted}{pycon}
>>> with open("hg38.chrom.sizes") as handle:
...     table = substitution_matrices.read(handle, int)
...
>>> print(table)  # doctest: +ELLIPSIS
chr1 248956422
chr2 242193529
chr3 198295559
chr4 190214555
...
chrUn_KI270423v1       981
chrUn_KI270392v1       971
chrUn_KI270394v1       970
<BLANKLINE>
\end{minted}

For two-dimensional arrays, we follow the file format of substitution matrices provided by NCBI. For example, the BLOSUM62 matrix, which is the default substitution matrix for NCBI's protein-protein BLAST \cite{altschul1990} program \verb+blastp+, is stored as follows:
\begin{minted}{text}
#  Matrix made by matblas from blosum62.iij
#  * column uses minimum score
#  BLOSUM Clustered Scoring Matrix in 1/2 Bit Units
#  Blocks Database = /data/blocks_5.0/blocks.dat
#  Cluster Percentage: >= 62
#  Entropy =   0.6979, Expected =  -0.5209
   A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  Z  X  *
A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0 -2 -1  0 -4
R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3 -1  0 -1 -4
N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  3  0 -1 -4
D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  4  1 -1 -4
C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1 -3 -3 -2 -4
Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0  3 -1 -4
E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  1  4 -1 -4
G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3 -1 -2 -1 -4
H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0  0 -1 -4
...
\end{minted}
This file is included in the Biopython distribution under \verb+Bio/Align/substitution_matrices/data+. To parse this file, use

%doctest ../Bio/Align/substitution_matrices/data lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align import substitution_matrices
>>> with open("BLOSUM62") as handle:
...     matrix = substitution_matrices.read(handle)
...
>>> print(matrix.alphabet)
ARNDCQEGHILKMFPSTWYVBZX*
>>> print(matrix["A", "D"])
-2.0
\end{minted}
The header lines starting with \verb+#+ are stored in the attribute \verb+header+:

%cont-doctest
\begin{minted}{pycon}
>>> matrix.header[0]
'Matrix made by matblas from blosum62.iij'
\end{minted}
We can now use this matrix as the substitution matrix on an aligner object:

%cont-doctest
\begin{minted}{pycon}
>>> from Bio.Align import PairwiseAligner
>>> aligner = PairwiseAligner()
>>> aligner.substitution_matrix = matrix
\end{minted}
To save an Array object, create a string first:

%cont-doctest
\begin{minted}{pycon}
>>> text = str(matrix)
>>> print(text)  # doctest: +ELLIPSIS
#  Matrix made by matblas from blosum62.iij
#  * column uses minimum score
#  BLOSUM Clustered Scoring Matrix in 1/2 Bit Units
#  Blocks Database = /data/blocks_5.0/blocks.dat
#  Cluster Percentage: >= 62
#  Entropy =   0.6979, Expected =  -0.5209
     A    R    N    D    C    Q    E    G    H    I    L    K    M    F    P    S ...
A  4.0 -1.0 -2.0 -2.0  0.0 -1.0 -1.0  0.0 -2.0 -1.0 -1.0 -1.0 -1.0 -2.0 -1.0  1.0 ...
R -1.0  5.0  0.0 -2.0 -3.0  1.0  0.0 -2.0  0.0 -3.0 -2.0  2.0 -1.0 -3.0 -2.0 -1.0 ...
N -2.0  0.0  6.0  1.0 -3.0  0.0  0.0  0.0  1.0 -3.0 -3.0  0.0 -2.0 -3.0 -2.0  1.0 ...
D -2.0 -2.0  1.0  6.0 -3.0  0.0  2.0 -1.0 -1.0 -3.0 -4.0 -1.0 -3.0 -3.0 -1.0  0.0 ...
C  0.0 -3.0 -3.0 -3.0  9.0 -3.0 -4.0 -3.0 -3.0 -1.0 -1.0 -3.0 -1.0 -2.0 -3.0 -1.0 ...
...
\end{minted}
and write the \verb+text+ to a file.

\subsection{Loading predefined substitution matrices}

Biopython contains a large set of substitution matrices defined in the literature, including BLOSUM (Blocks Substitution Matrix) \cite{henikoff1992} and PAM (Point Accepted Mutation) matrices \cite{dayhoff1978}. These matrices are available as flat files in the \verb+Bio/Align/substitution_matrices/data+ directory, and can be loaded into Python using the \verb+load+ function in the \verb+substitution_matrices+ submodule. For example, the BLOSUM62 matrix can be loaded by running

%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align import substitution_matrices
>>> m = substitution_matrices.load("BLOSUM62")
\end{minted}
This substitution matrix has an alphabet consisting of the 20 amino acids used in the genetic code, the three ambiguous amino acids B (asparagine or aspartic acid), Z (glutamine or glutamic acid), and X (representing any amino acid), and the stop codon represented by an asterisk:

%cont-doctest
\begin{minted}{pycon}
>>> m.alphabet
'ARNDCQEGHILKMFPSTWYVBZX*'
\end{minted}

To get a full list of available substitution matrices, use \verb+load+ without an argument:

%cont-doctest
\begin{minted}{pycon}
>>> substitution_matrices.load()  # doctest: +ELLIPSIS
['BENNER22', 'BENNER6', 'BENNER74', 'BLASTN', 'BLASTP', 'BLOSUM45', 'BLOSUM50', ..., 'TRANS']
\end{minted}

\hypertarget{codonmatrix}{
Note that the substitution matrix provided by Schneider \textit{et al.} \cite{schneider2005} uses an alphabet consisting of three-nucleotide codons:
}

%cont-doctest
\begin{minted}{pycon}
>>> m = substitution_matrices.load("SCHNEIDER")
>>> m.alphabet  # doctest: +ELLIPSIS
('AAA', 'AAC', 'AAG', 'AAT', 'ACA', 'ACC', 'ACG', 'ACT', ..., 'TTG', 'TTT')
\end{minted}
