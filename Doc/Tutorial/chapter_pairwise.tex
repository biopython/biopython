\chapter{Pairwise sequence alignment}
\label{chapter:pairwise}

Pairwise sequence alignment is the process of aligning two sequences to each
other by optimizing the similarity score between them.  The \verb|Bio.Align|
module contains the \verb|PairwiseAligner| class for global and local
alignments using the Needleman-Wunsch, Smith-Waterman, Gotoh (three-state), and
Waterman-Smith-Beyer global and local pairwise alignment algorithms, with
numerous options to change the alignment parameters.
We refer to Durbin \textit{et al.} \cite{durbin1998} for in-depth information on sequence alignment algorithms.

\section{Basic usage}
\label{sec:pairwise-basic}

To generate pairwise alignments, first create a \verb+PairwiseAligner+ object:

%doctest examples
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
\end{minted}
The \verb+PairwiseAligner+ object \verb+aligner+
(see Section~\ref{sec:pairwise-aligner})
stores the alignment parameters to be used for the pairwise alignments.

These attributes can be set in the constructor of the object or after the object
is made.

%cont-doctest
\begin{minted}{pycon}
>>> aligner = Align.PairwiseAligner(match_score=1.0)
\end{minted}

Or, equivalently:

%cont-doctest
\begin{minted}{pycon}
>>> aligner.match_score = 1.0
\end{minted}

Use the \verb+aligner.score+ method to calculate the alignment score between
two sequences:

%cont-doctest
\begin{minted}{pycon}
>>> target = "GAACT"
>>> query = "GAT"
>>> score = aligner.score(target, query)
>>> score
3.0
\end{minted}

To see the actual alignments, use the \verb+aligner.align+ method and iterate over the \verb+Alignment+ objects returned:

%cont-doctest
\begin{minted}{pycon}
>>> alignments = aligner.align(target, query)
>>> for alignment in alignments:
...     print(alignment)
...
target            0 GAACT 5
                  0 ||--| 5
query             0 GA--T 3
<BLANKLINE>
target            0 GAACT 5
                  0 |-|-| 5
query             0 G-A-T 3
<BLANKLINE>
\end{minted}

By default, a global pairwise alignment is performed, which finds the optimal
alignment over the whole length of \verb+target+ and \verb+query+.
Instead, a local alignment will find the subsequence of
\verb+target+ and \verb+query+ with the highest alignment score.
Local alignments can be generated by setting \verb+aligner.mode+ to
\verb+"local"+:

%cont-doctest
\begin{minted}{pycon}
>>> aligner.mode = "local"
>>> target = "AGAACTC"
>>> query = "GAACT"
>>> score = aligner.score(target, query)
>>> score
5.0
>>> alignments = aligner.align(target, query)
>>> for alignment in alignments:
...     print(alignment)
...
target            1 GAACT 6
                  0 ||||| 5
query             0 GAACT 5
<BLANKLINE>
\end{minted}

Note that there is some ambiguity in the definition of the best local alignments if segments with a score 0 can be added to the alignment. We follow the suggestion by Waterman \& Eggert \cite{waterman1987} and disallow such extensions.

\section{The pairwise aligner object}
\label{sec:pairwise-aligner}

The \verb+PairwiseAligner+ object stores all alignment parameters to be used
for the pairwise alignments. To see an overview of the values for all parameters, use

%cont-doctest
\begin{minted}{pycon}
>>> print(aligner)
Pairwise sequence aligner with parameters
  wildcard: None
  match_score: 1.000000
  mismatch_score: 0.000000
  target_internal_open_gap_score: 0.000000
  target_internal_extend_gap_score: 0.000000
  target_left_open_gap_score: 0.000000
  target_left_extend_gap_score: 0.000000
  target_right_open_gap_score: 0.000000
  target_right_extend_gap_score: 0.000000
  query_internal_open_gap_score: 0.000000
  query_internal_extend_gap_score: 0.000000
  query_left_open_gap_score: 0.000000
  query_left_extend_gap_score: 0.000000
  query_right_open_gap_score: 0.000000
  query_right_extend_gap_score: 0.000000
  mode: local
<BLANKLINE>
\end{minted}
See Sections~\ref{sec:pairwise-substitution-scores}, \ref{sec:pairwise-affine-gapscores}, and \ref{sec:pairwise-general-gapscores} below for the definition of these
parameters. The attribute \verb+mode+ (described above in Section~\ref{sec:pairwise-basic}) can be set equal to \verb+"global"+ or \verb+"local"+ to specify global or local pairwise alignment, respectively.

Depending on the gap scoring parameters
(see Sections~\ref{sec:pairwise-affine-gapscores} and
\ref{sec:pairwise-general-gapscores}) and mode, a \verb+PairwiseAligner+ object
automatically chooses the appropriate algorithm to use for pairwise sequence alignment. To verify the selected algorithm, use

%cont-doctest
\begin{minted}{pycon}
>>> aligner.algorithm
'Smith-Waterman'
\end{minted}
This attribute is read-only.

A \verb+PairwiseAligner+ object also stores the precision $\epsilon$ to be used during alignment. The value of $\epsilon$ is stored in the attribute \verb+aligner.epsilon+, and by default is equal to $10^{-6}$:


%cont-doctest
\begin{minted}{pycon}
>>> aligner.epsilon
1e-06
\end{minted}
Two scores will be considered equal to each other for the purpose of the alignment if the absolute difference between them is less than $\epsilon$.

\section{Substitution scores}
\label{sec:pairwise-substitution-scores}

Substitution scores define the value to be added to the total score when two letters (nucleotides or amino acids) are aligned to each other. The substitution scores to be used by the \verb+PairwiseAligner+ can be specified in two ways:

\begin{itemize}
\item By specifying a match score for identical letters, and a mismatch scores for mismatched letters. Nucleotide sequence alignments are typically based on match and mismatch scores. For example, by default BLAST \cite{altschul1990} uses a match score of $+1$ and a mismatch score of $-2$ for nucleotide alignments by \verb+megablast+, with a gap penalty of 2.5 (see section \ref{sec:pairwise-affine-gapscores} for more information on gap scores). Match and mismatch scores can be specified by setting the \verb+match+ and \verb+mismatch+ attributes of the \verb+PairwiseAligner+ object:

%doctest examples lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> aligner.match_score
1.0
>>> aligner.mismatch_score
0.0
>>> score = aligner.score("ACGT", "ACAT")
>>> print(score)
3.0
>>> aligner.match_score = 1.0
>>> aligner.mismatch_score = -2.0
>>> aligner.gap_score = -2.5
>>> score = aligner.score("ACGT", "ACAT")
>>> print(score)
1.0
\end{minted}
When using match and mismatch scores, you can specify a wildcard character (\verb+None+ by default) for unknown letters. These will get a zero score in alignments, irrespective of the value of the match or mismatch score:
%cont-doctest
\begin{minted}{pycon}
>>> aligner.wildcard = "?"
>>> score = aligner.score("ACGT", "AC?T")
>>> print(score)
3.0
\end{minted}
\item
Alternatively, you can use the \verb+substitution_matrix+ attribute of the \verb+PairwiseAligner+ object to specify a substitution matrix. This allows you to apply different scores for different pairs of matched and mismatched letters. This is typically used for amino acid sequence alignments. For example, by default BLAST \cite{altschul1990} uses the BLOSUM62 substitution matrix for protein alignments by \verb+blastp+. This substitution matrix is available from Biopython:

%cont-doctest
\begin{minted}{pycon}
>>> from Bio.Align import substitution_matrices
>>> substitution_matrices.load()  # doctest: +ELLIPSIS
['BENNER22', 'BENNER6', 'BENNER74', 'BLASTN', 'BLASTP', 'BLOSUM45', 'BLOSUM50', 'BLOSUM62', ..., 'TRANS']
>>> matrix = substitution_matrices.load("BLOSUM62")
>>> print(matrix)  # doctest: +ELLIPSIS
#  Matrix made by matblas from blosum62.iij
...
     A    R    N    D    C    Q ...
A  4.0 -1.0 -2.0 -2.0  0.0 -1.0 ...
R -1.0  5.0  0.0 -2.0 -3.0  1.0 ...
N -2.0  0.0  6.0  1.0 -3.0  0.0 ...
D -2.0 -2.0  1.0  6.0 -3.0  0.0 ...
C  0.0 -3.0 -3.0 -3.0  9.0 -3.0 ...
Q -1.0  1.0  0.0  0.0 -3.0  5.0 ...
...
>>> aligner.substitution_matrix = matrix
>>> score = aligner.score("ACDQ", "ACDQ")
>>> score
24.0
>>> score = aligner.score("ACDQ", "ACNQ")
>>> score
19.0
\end{minted}
When using a substitution matrix, \verb+X+ is {\em not} interpreted as an unknown character. Instead, the score provided by the substitution matrix will be used:

%cont-doctest
\begin{minted}{pycon}
>>> matrix["D", "X"]
-1.0
>>> score = aligner.score("ACDQ", "ACXQ")
>>> score
17.0
\end{minted}
\end{itemize}

By default, \verb+aligner.substitution_matrix+ is \verb+None+.
The attributes \verb+aligner.match_score+ and \verb+aligner.mismatch_score+ are
ignored if \verb+aligner.substitution_matrix+ is not \verb+None+.
Setting \verb+aligner.match_score+ or \verb+aligner.mismatch_score+ to valid values will reset \verb+aligner.substitution_matrix+ to \verb+None+.

\section{Affine gap scores}
\label{sec:pairwise-affine-gapscores}

Affine gap scores are defined by a score to open a gap, and a score to extend
an existing gap:

$\textrm{gap score} = \textrm{open gap score} + (n-1) \times \textrm{extend gap score}$,

where $n$ is the length of the gap.
Biopython's pairwise sequence aligner allows fine-grained control over the gap
scoring scheme by specifying the following twelve attributes of a \verb+PairwiseAligner+ object:

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
\textbf{Opening scores}               & \textbf{Extending scores} \\
\hline
\verb+query_left_open_gap_score+      & \verb+query_left_extend_gap_score+ \\
\verb+query_internal_open_gap_score+  & \verb+query_internal_extend_gap_score+ \\
\verb+query_right_open_gap_score+     & \verb+query_right_extend_gap_score+ \\
\verb+target_left_open_gap_score+     & \verb+target_left_extend_gap_score+ \\
\verb+target_internal_open_gap_score+ & \verb+target_internal_extend_gap_score+ \\
\verb+target_right_open_gap_score+    & \verb+target_right_extend_gap_score+ \\
\hline
\end{tabular}
\end{table}

These attributes allow for different gap scores for internal gaps and on either end of the sequence, as shown in this example:

\begin{table}[h]
\begin{tabular}{|c|c|l|}
\hline
\textbf{target} & \textbf{query} & \textbf{score} \\
\hline
A & - &  query left open gap score \\
C & - &  query left extend gap score \\
C & - &  query left extend gap score \\
G & G &  match score \\
G & T &  mismatch score \\
G & - &  query internal open gap score \\
A & - &  query internal extend gap score \\
A & - &  query internal extend gap score \\
T & T &  match score \\
A & A &  match score \\
G & - &  query internal open gap score \\
C & C &  match score \\
- & C &  target internal open gap score \\
- & C &  target internal extend gap score \\
C & C &  match score \\
T & G &  mismatch score \\
C & C &  match score \\
- & C &  target internal open gap score \\
A & A &  match score \\
- & T &  target right open gap score \\
- & A &  target right extend gap score \\
- & A &  target right extend gap score \\
\hline
\end{tabular}
\end{table}

For convenience, \verb+PairwiseAligner+ objects have additional attributes that refer to a number of these values collectively, as shown (hierarchically) in Table~\ref{table:align-meta-attributes}.

\begin{table}
\caption{Meta-attributes of the pairwise aligner objects.}
\begin{tabular}{|l|l|}
\hline
\textbf{Meta-attribute} & \textbf{Attributes it maps to} \\
\hline
\verb+gap_score+ & \verb+target_gap_score+, \verb+query_gap_score+ \\
\verb+open_gap_score+ & \verb+target_open_gap_score+, \verb+query_open_gap_score+ \\
\verb+extend_gap_score+ & \verb+target_extend_gap_score+, \verb+query_extend_gap_score+ \\
\verb+internal_gap_score+ & \verb+target_internal_gap_score+, \verb+query_internal_gap_score+ \\
\verb+internal_open_gap_score+ & \verb+target_internal_open_gap_score+, \verb+query_internal_open_gap_score+ \\
\verb+internal_extend_gap_score+ & \verb+target_internal_extend_gap_score+, \verb+query_internal_extend_gap_score+ \\
\verb+end_gap_score+ & \verb+target_end_gap_score+, \verb+query_end_gap_score+ \\
\verb+end_open_gap_score+ & \verb+target_end_open_gap_score+, \verb+query_end_open_gap_score+ \\
\verb+end_extend_gap_score+ & \verb+target_end_extend_gap_score+, \verb+query_end_extend_gap_score+ \\
\verb+left_gap_score+ & \verb+target_left_gap_score+, \verb+query_left_gap_score+ \\
\verb+right_gap_score+ & \verb+target_right_gap_score+, \verb+query_right_gap_score+ \\
\verb+left_open_gap_score+ & \verb+target_left_open_gap_score+, \verb+query_left_open_gap_score+ \\
\verb+left_extend_gap_score+ & \verb+target_left_extend_gap_score+, \verb+query_left_extend_gap_score+ \\
\verb+right_open_gap_score+ & \verb+target_right_open_gap_score+, \verb+query_right_open_gap_score+ \\
\verb+right_extend_gap_score+ & \verb+target_right_extend_gap_score+, \verb+query_right_extend_gap_score+ \\
\verb+target_open_gap_score+ & \verb+target_internal_open_gap_score+, \verb+target_left_open_gap_score+, \\
                             & \verb+target_right_open_gap_score+ \\
\verb+target_extend_gap_score+ & \verb+target_internal_extend_gap_score+, \verb+target_left_extend_gap_score+, \\
                               & \verb+target_right_extend_gap_score+ \\
\verb+target_gap_score+ & \verb+target_open_gap_score+, \verb+target_extend_gap_score+ \\
\verb+query_open_gap_score+ & \verb+query_internal_open_gap_score+, \verb+query_left_open_gap_score+, \\
                            & \verb+query_right_open_gap_score+ \\
\verb+query_extend_gap_score+ & \verb+query_internal_extend_gap_score+, \verb+query_left_extend_gap_score+, \\
                              & \verb+query_right_extend_gap_score+ \\
\verb+query_gap_score+ & \verb+query_open_gap_score+, \verb+query_extend_gap_score+ \\
\verb+target_internal_gap_score+ & \verb+target_internal_open_gap_score+, \verb+target_internal_extend_gap_score+ \\
\verb+target_end_gap_score+ & \verb+target_end_open_gap_score+, \verb+target_end_extend_gap_score+ \\
\verb+target_end_open_gap_score+ & \verb+target_left_open_gap_score+, \verb+target_right_open_gap_score+ \\
\verb+target_end_extend_gap_score+ & \verb+target_left_extend_gap_score+, \verb+target_right_extend_gap_score+ \\
\verb+target_left_gap_score+ & \verb+target_left_open_gap_score+, \verb+target_left_extend_gap_score+ \\
\verb+target_right_gap_score+ & \verb+target_right_open_gap_score+, \verb+target_right_extend_gap_score+ \\
\verb+query_end_gap_score+ & \verb+query_end_open_gap_score+, \verb+query_end_extend_gap_score+ \\
\verb+query_end_open_gap_score+ & \verb+query_left_open_gap_score+, \verb+query_right_open_gap_score+ \\
\verb+query_end_extend_gap_score+ & \verb+query_left_extend_gap_score+, \verb+query_right_extend_gap_score+ \\
\verb+query_internal_gap_score+ & \verb+query_internal_open_gap_score+, \verb+query_internal_extend_gap_score+ \\
\verb+query_left_gap_score+ & \verb+query_left_open_gap_score+, \verb+query_left_extend_gap_score+ \\
\verb+query_right_gap_score+ & \verb+query_right_open_gap_score+, \verb+query_right_extend_gap_score+ \\
\hline
\end{tabular}
\label{table:align-meta-attributes}
\end{table}

\section{General gap scores}
\label{sec:pairwise-general-gapscores}

For even more fine-grained control over the gap scores, you can specify a gap scoring function. For example, the gap scoring function below disallows a gap after two nucleotides in the query sequence:

%doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> def my_gap_score_function(start, length):
...     if start == 2:
...         return -1000
...     else:
...         return -1 * length
...
>>> aligner.query_gap_score = my_gap_score_function
>>> alignments = aligner.align("AACTT", "AATT")
>>> for alignment in alignments:
...     print(alignment)
...
target            0 AACTT 5
                  0 -|.|| 5
query             0 -AATT 4
<BLANKLINE>
target            0 AACTT 5
                  0 |-.|| 5
query             0 A-ATT 4
<BLANKLINE>
target            0 AACTT 5
                  0 ||.-| 5
query             0 AAT-T 4
<BLANKLINE>
target            0 AACTT 5
                  0 ||.|- 5
query             0 AATT- 4
<BLANKLINE>
\end{minted}

\section{Using a pre-defined substitution matrix and gap scores}
\label{sec:pairwise-predefined-scoring}

By default, a \verb+PairwiseAligner+ object is initialized with a match score of +1.0, a mismatch score of 0.0, and all gap scores equal to 0.0, While this has the benefit of being a simple scoring scheme, in general it does not give the best performance. Instead, you can use the argument \verb+scoring+ to select a predefined scoring scheme when initializing a \verb+PairwiseAligner+ object. Currently, the provided scoring schemes are \verb+blastn+ and \verb+megablast+, which are suitable for nucleotide alignments, and \verb+blastp+, which is suitable for protein alignments. Selecting these scoring schemes will initialize the \verb+PairwiseAligner+ object to the default scoring parameters used by BLASTN, MegaBLAST, and BLASTP, respectively.

%doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner(scoring="blastn")
>>> print(aligner)  # doctest:+ELLIPSIS
Pairwise sequence aligner with parameters
  substitution_matrix: <Array object at ...>
  target_internal_open_gap_score: -7.000000
  target_internal_extend_gap_score: -2.000000
  target_left_open_gap_score: -7.000000
  target_left_extend_gap_score: -2.000000
  target_right_open_gap_score: -7.000000
  target_right_extend_gap_score: -2.000000
  query_internal_open_gap_score: -7.000000
  query_internal_extend_gap_score: -2.000000
  query_left_open_gap_score: -7.000000
  query_left_extend_gap_score: -2.000000
  query_right_open_gap_score: -7.000000
  query_right_extend_gap_score: -2.000000
  mode: global
<BLANKLINE>
>>> print(aligner.substitution_matrix[:, :])
     A    T    G    C    S    W    R    Y    K    M    B    V    H    D    N
A  2.0 -3.0 -3.0 -3.0 -3.0 -1.0 -1.0 -3.0 -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -2.0
T -3.0  2.0 -3.0 -3.0 -3.0 -1.0 -3.0 -1.0 -1.0 -3.0 -1.0 -3.0 -1.0 -1.0 -2.0
G -3.0 -3.0  2.0 -3.0 -1.0 -3.0 -1.0 -3.0 -1.0 -3.0 -1.0 -1.0 -3.0 -1.0 -2.0
C -3.0 -3.0 -3.0  2.0 -1.0 -3.0 -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -3.0 -2.0
S -3.0 -3.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
W -1.0 -1.0 -3.0 -3.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
R -1.0 -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
Y -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
K -3.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -2.0
M -1.0 -3.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
B -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
V -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
H -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
D -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
N -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0
<BLANKLINE>
\end{minted}

\section{Iterating over alignments}

The \verb+alignments+ returned by \verb+aligner.align+ are a kind of immutable iterable objects (similar to \verb+range+). While they appear similar to a \verb+tuple+ or \verb+list+ of \verb+Alignment+ objects, they are different in the sense that each \verb+Alignment+ object is created dynamically when it is needed. This approach was chosen because the number of alignments can be extremely large, in particular for poor alignments (see Section~\ref{sec:pairwise-examples} for an example).

You can perform the following operations on \verb+alignments+:
\begin{itemize}
\item \verb+len(alignments)+ returns the number of alignments stored. This function returns quickly, even if the number of alignments is huge. If the number of alignments is extremely large (typically, larger than 9,223,372,036,854,775,807, which is the largest integer that can be stored as a \verb+long int+ on 64 bit machines), \verb+len(alignments)+ will raise an \verb+OverflowError+. A large number of alignments suggests that the alignment quality is low.

%doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> alignments = aligner.align("AAA", "AA")
>>> len(alignments)
3
\end{minted}
\item You can extract a specific alignment by index:

%doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> alignments = aligner.align("AAA", "AA")
>>> print(alignments[2])
target            0 AAA 3
                  0 -|| 3
query             0 -AA 2
<BLANKLINE>
>>> print(alignments[0])
target            0 AAA 3
                  0 ||- 3
query             0 AA- 2
<BLANKLINE>
\end{minted}
\item You can iterate over alignments, for example as in
\begin{minted}{pycon}
>>> for alignment in alignments:
...     print(alignment)
...
\end{minted}
By calling \verb+alignments.rewind+, you can rewind the \verb+alignments+ iterator to the first alignment and iterate over the alignments from the beginning:

%doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> alignments = aligner.align("AAA", "AA")
>>> for alignment in alignments:
...     print(alignment)
...
target            0 AAA 3
                  0 ||- 3
query             0 AA- 2
<BLANKLINE>
target            0 AAA 3
                  0 |-| 3
query             0 A-A 2
<BLANKLINE>
target            0 AAA 3
                  0 -|| 3
query             0 -AA 2
<BLANKLINE>
>>> alignments.rewind()
>>> for alignment in alignments:
...     print(alignment)
...
target            0 AAA 3
                  0 ||- 3
query             0 AA- 2
<BLANKLINE>
target            0 AAA 3
                  0 |-| 3
query             0 A-A 2
<BLANKLINE>
target            0 AAA 3
                  0 -|| 3
query             0 -AA 2
<BLANKLINE>
\end{minted}
You can also convert the \verb+alignments+ iterator into a \verb+list+ or \verb+tuple+:
\begin{minted}{pycon}
>>> alignments = list(alignments)
\end{minted}
It is wise to check the number of alignments by calling \verb+len(alignments)+ before attempting to call \verb+list(alignments)+ to save all alignments as a list.
\item The alignment score (which has the same value for each alignment in \verb+alignments+) is stored as an attribute. This allows you to check the alignment score before proceeding to extract individual alignments:

%cont-doctest
\begin{minted}{pycon}
>>> print(alignments.score)
2.0
\end{minted}
\end{itemize}

\section{Aligning to the reverse strand}

By default, the pairwise aligner aligns the forward strand of the query to the forward strand of the target. To calculate the alignment score for \verb+query+ to the reverse strand of \verb+target+, use \verb+strand="-"+:
%doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> from Bio.Seq import reverse_complement
>>> target = "AAAACCC"
>>> query = "AACC"
>>> aligner = Align.PairwiseAligner()
>>> aligner.mismatch_score = -1
>>> aligner.internal_gap_score = -1
>>> aligner.score(target, query)  # strand is "+" by default
4.0
>>> aligner.score(target, reverse_complement(query), strand="-")
4.0
>>> aligner.score(target, query, strand="-")
0.0
>>> aligner.score(target, reverse_complement(query))
0.0

\end{minted}

The alignments against the reverse strand can be obtained by specifying \verb+strand="-"+ when calling \verb+aligner.align+:
%cont-doctest
\begin{minted}{pycon}
>>> alignments = aligner.align(target, query)
>>> len(alignments)
1
>>> print(alignments[0])
target            0 AAAACCC 7
                  0 --||||- 7
query             0 --AACC- 4
<BLANKLINE>
>>> print(alignments[0].format("bed"))  # doctest: +NORMALIZE_WHITESPACE
target   2   6   query   4.0   +   2   6   0   1   4,   0,
<BLANKLINE>
>>> alignments = aligner.align(target, reverse_complement(query), strand="-")
>>> len(alignments)
1
>>> print(alignments[0])
target            0 AAAACCC 7
                  0 --||||- 7
query             4 --AACC- 0
<BLANKLINE>
>>> print(alignments[0].format("bed"))  # doctest: +NORMALIZE_WHITESPACE
target   2   6   query   4.0   -   2   6   0   1   4,   0,
<BLANKLINE>
>>> alignments = aligner.align(target, query, strand="-")
>>> len(alignments)
2
>>> print(alignments[0])
target            0 AAAACCC----  7
                  0 ----------- 11
query             4 -------GGTT  0
<BLANKLINE>
>>> print(alignments[1])
target            0 ----AAAACCC  7
                  0 ----------- 11
query             4 GGTT-------  0
<BLANKLINE>
\end{minted}

Note that the score for aligning \verb+query+ to the reverse strand of \verb+target+ may be different from the score for aligning the reverse complement of \verb+query+ to the forward strand of \verb+target+ if the left and right gap scores are different:
%cont-doctest
\begin{minted}{pycon}
>>> aligner.left_gap_score = -0.5
>>> aligner.right_gap_score = -0.2
>>> aligner.score(target, query)
2.8
>>> alignments = aligner.align(target, query)
>>> len(alignments)
1
>>> print(alignments[0])
target            0 AAAACCC 7
                  0 --||||- 7
query             0 --AACC- 4
<BLANKLINE>
>>> aligner.score(target, reverse_complement(query), strand="-")
3.1
>>> alignments = aligner.align(target, reverse_complement(query), strand="-")
>>> len(alignments)
1
>>> print(alignments[0])
target            0 AAAACCC 7
                  0 --||||- 7
query             4 --AACC- 0
<BLANKLINE>
\end{minted}


\section{Examples}
\label{sec:pairwise-examples}

Suppose you want to do a global pairwise alignment between the same two
hemoglobin sequences from above (\texttt{HBA\_HUMAN}, \texttt{HBB\_HUMAN})
stored in \texttt{alpha.faa} and \texttt{beta.faa}:

%doctest examples
\begin{minted}{pycon}
>>> from Bio import Align
>>> from Bio import SeqIO
>>> seq1 = SeqIO.read("alpha.faa", "fasta")
>>> seq2 = SeqIO.read("beta.faa", "fasta")
>>> aligner = Align.PairwiseAligner()
>>> score = aligner.score(seq1.seq, seq2.seq)
>>> print(score)
72.0
\end{minted}

showing an alignment score of 72.0. To see the individual alignments, do

%cont-doctest
\begin{minted}{pycon}
>>> alignments = aligner.align(seq1.seq, seq2.seq)
\end{minted}
In this example, the total number of optimal alignments is huge (more than $4 \times 10^{37}$), and calling \verb+len(alignments)+ will raise an \verb+OverflowError+:

% don't include in the doctest, as 32-bit system show a different number
\begin{minted}{pycon}
>>> len(alignments)
Traceback (most recent call last):
...
OverflowError: number of optimal alignments is larger than 9223372036854775807
\end{minted}
Let's have a look at the first alignment:

%cont-doctest
\begin{minted}{pycon}
>>> alignment = alignments[0]
\end{minted}

The alignment object stores the alignment score, as well as the alignment
itself:

%cont-doctest
\begin{minted}{pycon}
>>> print(alignment.score)
72.0
>>> print(alignment)
target            0 MV-LS-PAD--KTN--VK-AA-WGKV-----GAHAGEYGAEALE-RMFLSF----P-TTK
                  0 ||-|--|----|----|--|--||||-----|---||--|--|--|--|------|-|--
query             0 MVHL-TP--EEK--SAV-TA-LWGKVNVDEVG---GE--A--L-GR--L--LVVYPWT--
<BLANKLINE>
target           41 TY--FPHF----DLSHGS---AQVK-G------HGKKV--A--DA-LTNAVAHV-DDMPN
                 60 ----|--|----|||------|-|--|------|||||--|--|--|--|--|--|---|
query            39 --QRF--FESFGDLS---TPDA-V-MGNPKVKAHGKKVLGAFSD-GL--A--H-LD---N
<BLANKLINE>
target           79 ALS----A-LSD-LHAH--KLR-VDPV-NFK-LLSHC---LLVT--LAAHLPA----EFT
                120 -|-----|-||--||----||--|||--||--||------|-|---||-|-------|||
query            81 -L-KGTFATLS-ELH--CDKL-HVDP-ENF-RLL---GNVL-V-CVLA-H---HFGKEFT
<BLANKLINE>
target          119 PA-VH-ASLDKFLAS---VSTV------LTS--KYR- 142
                180 |--|--|------|----|--|------|----||-- 217
query           124 P-PV-QA------A-YQKV--VAGVANAL--AHKY-H 147
<BLANKLINE>
\end{minted}

Better alignments are usually obtained by penalizing gaps: higher costs
for opening a gap and lower costs for extending an existing gap. For amino
acid sequences match scores are usually encoded in matrices like \texttt{PAM}
or \texttt{BLOSUM}. Thus, a more meaningful alignment for our example can be
obtained by using the BLOSUM62 matrix, together with a gap open penalty of 10
and a gap extension penalty of 0.5:

%doctest examples lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> from Bio import SeqIO
>>> from Bio.Align import substitution_matrices
>>> seq1 = SeqIO.read("alpha.faa", "fasta")
>>> seq2 = SeqIO.read("beta.faa", "fasta")
>>> aligner = Align.PairwiseAligner()
>>> aligner.open_gap_score = -10
>>> aligner.extend_gap_score = -0.5
>>> aligner.substitution_matrix = substitution_matrices.load("BLOSUM62")
>>> score = aligner.score(seq1.seq, seq2.seq)
>>> print(score)
292.5
>>> alignments = aligner.align(seq1.seq, seq2.seq)
>>> len(alignments)
2
>>> print(alignments[0].score)
292.5
>>> print(alignments[0])
target            0 MV-LSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHF-DLS-----HGS
                  0 ||-|.|..|..|.|.||||--...|.|.|||.|.....|.|...|..|-|||-----.|.
query             0 MVHLTPEEKSAVTALWGKV--NVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGN
<BLANKLINE>
target           53 AQVKGHGKKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAH
                 60 ..||.|||||..|.....||.|........||.||..||.|||.||.||...|...||.|
query            58 PKVKAHGKKVLGAFSDGLAHLDNLKGTFATLSELHCDKLHVDPENFRLLGNVLVCVLAHH
<BLANKLINE>
target          113 LPAEFTPAVHASLDKFLASVSTVLTSKYR 142
                120 ...||||.|.|...|..|.|...|..||. 149
query           118 FGKEFTPPVQAAYQKVVAGVANALAHKYH 147
<BLANKLINE>
\end{minted}

This alignment has the same score that we obtained earlier with EMBOSS needle
using the same sequences and the same parameters.

To perform a local alignment, set \verb+aligner.mode+ to \verb+'local'+:

%cont-doctest
\begin{minted}{pycon}
>>> aligner.mode = "local"
>>> aligner.open_gap_score = -10
>>> aligner.extend_gap_score = -1
>>> alignments = aligner.align("LSPADKTNVKAA", "PEEKSAV")
>>> print(len(alignments))
1
>>> alignment = alignments[0]
>>> print(alignment)
target            2 PADKTNV 9
                  0 |..|..| 7
query             0 PEEKSAV 7
<BLANKLINE>
>>> print(alignment.score)
16.0
\end{minted}

\section{Generalized pairwise alignments}
\label{sec:generalized-pairwise}

In most cases, \verb+PairwiseAligner+ is used to perform alignments of sequences (strings or \verb+Seq+ objects) consisting of single-letter nucleotides or amino acids. More generally, \verb+PairwiseAligner+ can also be applied to lists or tuples of arbitrary objects. This section will describe some examples of such generalized pairwise alignments.

\subsection{Generalized pairwise alignments using a substitution matrix and alphabet}

Schneider \textit{et al.} \cite{schneider2005} created a substitution matrix for aligning three-nucleotide codons (see \hyperlink{codonmatrix}{below} in section~\ref{sec:substitution_matrices} for more information). This substitution matrix is associated with an alphabet consisting of all three-letter codons:

%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio.Align import substitution_matrices
>>> m = substitution_matrices.load("SCHNEIDER")
>>> m.alphabet  # doctest: +ELLIPSIS
('AAA', 'AAC', 'AAG', 'AAT', 'ACA', 'ACC', 'ACG', 'ACT', ..., 'TTG', 'TTT')
\end{minted}
We can use this matrix to align codon sequences to each other:

%cont-doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> aligner.substitution_matrix = m
>>> aligner.gap_score = -1.0
>>> s1 = ("AAT", "CTG", "TTT", "TTT")
>>> s2 = ("AAT", "TTA", "TTT")
>>> alignments = aligner.align(s1, s2)
>>> len(alignments)
2
>>> print(alignments[0])
AAT CTG TTT TTT
||| ... ||| ---
AAT TTA TTT ---
<BLANKLINE>
>>> print(alignments[1])
AAT CTG TTT TTT
||| ... --- |||
AAT TTA --- TTT
<BLANKLINE>
\end{minted}
Note that aligning \verb+TTT+ to \verb+TTA+, as in this example:
\begin{minted}{pycon}
AAT CTG TTT TTT
||| --- ... |||
AAT --- TTA TTT
\end{minted}
would get a much lower score:

%cont-doctest
\begin{minted}{pycon}
>>> print(m["CTG", "TTA"])
7.6
>>> print(m["TTT", "TTA"])
-0.3
\end{minted}
presumably because \verb+CTG+ and \verb+TTA+ both code for leucine, while \verb+TTT+ codes for phenylalanine. The three-letter codon substitution matrix also reveals a preference among codons representing the same amino acid. For example, \verb+TTA+ has a preference for \verb+CTG+ preferred compared to \verb+CTC+, though all three code for leucine:

%cont-doctest
\begin{minted}{pycon}
>>> s1 = ("AAT", "CTG", "CTC", "TTT")
>>> s2 = ("AAT", "TTA", "TTT")
>>> alignments = aligner.align(s1, s2)
>>> len(alignments)
1
>>> print(alignments[0])
AAT CTG CTC TTT
||| ... --- |||
AAT TTA --- TTT
<BLANKLINE>
>>> print(m["CTC", "TTA"])
6.5
\end{minted}

\subsection{Generalized pairwise alignments using match/mismatch scores and an alphabet}

Using the three-letter amino acid symbols, the sequences above translate to

%doctest
\begin{minted}{pycon}
>>> s1 = ("Asn", "Leu", "Leu", "Phe")
>>> s2 = ("Asn", "Leu", "Phe")
\end{minted}
We can align these sequences directly to each other by using a three-letter amino acid alphabet:

%cont-doctest
\begin{minted}{pycon}
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> aligner.alphabet = ['Ala', 'Arg', 'Asn', 'Asp', 'Cys',
...                     'Gln', 'Glu', 'Gly', 'His', 'Ile',
...                     'Leu', 'Lys', 'Met', 'Phe', 'Pro',
...                     'Ser', 'Thr', 'Trp', 'Tyr', 'Val']  # fmt: skip
...
\end{minted}
We use +6/-1 match and mismatch scores as an approximation of the BLOSUM62 matrix, and align these sequences to each other:

%cont-doctest
\begin{minted}{pycon}
>>> aligner.match = +6
>>> aligner.mismatch = -1
>>> alignments = aligner.align(s1, s2)
>>> print(len(alignments))
2
>>> print(alignments[0])
Asn Leu Leu Phe
||| ||| --- |||
Asn Leu --- Phe
<BLANKLINE>
>>> print(alignments[1])
Asn Leu Leu Phe
||| --- ||| |||
Asn --- Leu Phe
<BLANKLINE>
>>> print(alignments.score)
18.0
\end{minted}

\subsection{Generalized pairwise alignments using match/mismatch scores and integer sequences}

Internally, the first step when performing an alignment is to replace the two sequences by integer arrays consisting of the indices of each letter in each sequence in the alphabet associated with the aligner. This step can be bypassed by passing integer arrays directly:

%doctest . lib:numpy
\begin{minted}{pycon}
>>> import numpy as np
>>> from Bio import Align
>>> aligner = Align.PairwiseAligner()
>>> s1 = np.array([2, 10, 10, 13], np.int32)
>>> s2 = np.array([2, 10, 13], np.int32)
>>> aligner.match = +6
>>> aligner.mismatch = -1
>>> alignments = aligner.align(s1, s2)
>>> print(len(alignments))
2
>>> print(alignments[0])
2 10 10 13
| || -- ||
2 10 -- 13
<BLANKLINE>
>>> print(alignments[1])
2 10 10 13
| -- || ||
2 -- 10 13
<BLANKLINE>
>>> print(alignments.score)
18.0
\end{minted}
Note that the indices should consist of 32-bit integers, as specified in this example by \verb+numpy.int32+.

Unknown letters can again be included by defining a wildcard character, and using the corresponding Unicode code point number as the index:

%cont-doctest
\begin{minted}{pycon}
>>> aligner.wildcard = "?"
>>> ord(aligner.wildcard)
63
>>> s2 = np.array([2, 63, 13], np.int32)
>>> aligner.gap_score = -3
>>> alignments = aligner.align(s1, s2)
>>> print(len(alignments))
2
>>> print(alignments[0])
2 10 10 13
| .. -- ||
2 63 -- 13
<BLANKLINE>
>>> print(alignments[1])
2 10 10 13
| -- .. ||
2 -- 63 13
<BLANKLINE>
>>> print(alignments.score)
9.0
\end{minted}

\subsection{Generalized pairwise alignments using a substitution matrix and integer sequences}

Integer sequences can also be aligned using a substitution matrix, in this case a numpy square array without an alphabet associated with it. In this case, all index values must be non-negative, and smaller than the size of the substitution matrix:

%doctest . lib:numpy
\begin{minted}{pycon}
>>> from Bio import Align
>>> import numpy as np
>>> aligner = Align.PairwiseAligner()
>>> m = np.eye(5)
>>> m[0, 1:] = m[1:, 0] = -2
>>> m[2, 2] = 3
>>> print(m)
[[ 1. -2. -2. -2. -2.]
 [-2.  1.  0.  0.  0.]
 [-2.  0.  3.  0.  0.]
 [-2.  0.  0.  1.  0.]
 [-2.  0.  0.  0.  1.]]
>>> aligner.substitution_matrix = m
>>> aligner.gap_score = -1
>>> s1 = np.array([0, 2, 3, 4], np.int32)
>>> s2 = np.array([0, 3, 2, 1], np.int32)
>>> alignments = aligner.align(s1, s2)
>>> print(len(alignments))
2
>>> print(alignments[0])
0 - 2 3 4
| - | . -
0 3 2 1 -
<BLANKLINE>
>>> print(alignments[1])
0 - 2 3 4
| - | - .
0 3 2 - 1
<BLANKLINE>
>>> print(alignments.score)
2.0
\end{minted}
